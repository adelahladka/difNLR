{
    "collab_server" : "",
    "contents" : "#' Performs DIF detection using Non-Linear Regression method.\n#'\n#' @aliases difNLR print.difNLR plot.difNLR fitted.difNLR predict.difNLR coef.difNLR\n#'\n#' @description Performs DIF detection procedure based on Non-Linear Regression and either likelihood-ratio\n#' or F test of submodel.\n#'\n#' @param Data numeric: either the scored data matrix only, or the scored data\n#' matrix plus the vector of group. See \\strong{Details}.\n#' @param group numeric or character: either the binary vector of group membership or\n#' the column indicator of group membership. See \\strong{Details}.\n#' @param focal.name numeric or character: indicated the level of \\code{group} which corresponds to\n#' focal group\n#' @param model character: generalized logistic regression model to be fitted. See \\strong{Details}.\n#' @param type character: type of DIF to be tested (either \"both\" (default), \"udif\", or \"nudif\").\n#' See \\strong{Details}.\n#' @param test character: test to be performed for DIF detection (either \"F\" (default), or \"LR\").\n#' See \\strong{Details}.\n#' @param alpha numeric: significance level (default is 0.05).\n#' @param p.adjust.method character: method for multiple comparison correction. See \\strong{Details}.\n#' @param start numeric: matrix with n rows (where n is the number of items) and at most 5 columns\n#' containing initial item parameters estimates. See \\strong{Details}.\n#' @param x an object of 'difNLR' class\n#' @param object an object of 'difNLR' class\n#' @param plot.type character: type of plot to be plotted (either \"cc\" for characteristic curve\n#' (default), or \"stat\" for test statistics). See \\strong{Details}.\n#' @param item either character (\"all\"), or numeric vector, or single number corresponding to column indicators. See \\strong{Details}.\n#' @param col character: single value, or vector of two values representing colors for plot.\n#' @param shape integer: shape parameter for plot.\n#' @param size numeric: single number, or vector of two numbers representing line width in plot.\n#' @param linetype numeric: single number, or vector of two numbers representing line type in plot for reference and focal group.\n#' @param title string: title of plot.\n#' @param score numeric: standardized total score of subject.\n#' @param ... other generic parameters for \\code{print}, \\code{plot}, \\code{fitted},\n#' \\code{predict} or \\code{coef} functions.\n#'\n#' @usage difNLR(Data, group, focal.name, model, type = \"both\",\n#' test = \"LR\", alpha = 0.05, p.adjust.method = \"none\", start)\n#'\n#' @details\n#' DIF detection procedure based on Non-Linear Regression is the extension of Logistic Regression\n#' procedure (Swaminathan and Rogers, 1990).\n#'\n#' The \\code{Data} is a matrix whose rows represents scored examinee answers (\"1\" correct,\n#' \"0\" incorrect) and columns correspond to the items. In addition, \\code{Data} can hold\n#' the vector of group membership. If so, \\code{group} is a column indicator of \\code{Data}.\n#' Otherwise, \\code{group} must be either a vector of the same length as \\code{nrow(Data)}.\n#'\n#' The options of \\code{model} are as follows: \\code{Rasch} for one-parameter logistic model with\n#' discrimination parameter fixed on value 1 for both groups, \\code{1PL} for one-parameter logistic\n#' model with discrimination parameter fixed for both groups, \\code{2PL} for logistic regression model,\n#' \\code{3PLcg} for three-parameter logistic regression model with fixed guessing for both groups,\n#' \\code{3PLdg} for three-parameter logistic regression model with fixed inattention for both groups, or\n#' \\code{4PLcgdg} for four-parameter logistic regression model with fixed guessing and inattention\n#' parameter for both groups.\n#'\n#' The \\code{type} corresponds to type of DIF to be tested. Possible values are \\code{\"both\"} to\n#' detect any DIF (uniform and/or non-uniform), \\code{\"udif\"} to detect only uniform DIF or\n#' \\code{\"nudif\"} to detect only non-uniform DIF.\n#'\n#' The \\code{p.adjust.method} is a character for \\code{p.adjust} function from the \\code{stats}\n#' package. Possible values are \\code{\"holm\"}, \\code{\"hochberg\"}, \\code{\"hommel\"},\n#' \\code{\"bonferroni\"}, \\code{\"BH\"}, \\code{\"BY\"}, \\code{\"fdr\"}, \\code{\"none\"}.\n#'\n#' The \\code{start} is a matrix with a number of rows equal to number of items and with 8 columns.\n#' First 4 columns represent parameters (a, b, c, d) of generalized logistic regression model\n#' for reference group. Last 4 columns represent differences of parameters (aDif, bDif, cDif, dDif)\n#' of generalized logistic regression model between reference and focal group.\n#'\n#' The output of the difNLR is displayed by the \\code{print.difNLR} function.\n#'\n#' Two types of plots are available. The first one is obtained by setting \\code{plot.type = \"cc\"}\n#' (default). The characteristic curve for item specified in \\code{item} option is plotted. For default\n#' option \\code{\"all\"} of item, characteristic curves of all converged items are plotted. The drawn\n#' curves represent best model.\n#' The second plot is obtained by setting \\code{plot.type = \"stat\"}. The  test statistics\n#' (either F-test, or LR-test, depends on argument \\code{test}) are displayed on the Y axis,\n#' for each coverged item. The detection threshold is displayed by a horizontal line and items\n#' detected as DIF are printed with the red color. Only parameters \\code{size} and \\code{title}\n#' are used.\n#'\n#' Fitted values are extracted by the \\code{fitted.difNLR} function for item(s) specified in\n#' \\code{item} argument.\n#'\n#' Predicted values are produced by the \\code{predict.difNLR} function for item(s) specified in\n#' \\code{item} argument. \\code{score} represents standardized total score of new subject and\n#' \\code{group} argument represents group membership of new subject.\n#'\n#' Missing values are allowed but discarded for item estimation. They must be coded as\n#' \\code{NA} for both, \\code{data} and \\code{group} parameters.\n#'\n#' @return A list of class 'difNLR' with the following arguments:\n#' \\describe{\n#'   \\item{\\code{Sval}}{the values of likelihood ratio test statistics.}\n#'   \\item{\\code{nlrPAR}}{the estimates of final model.}\n#'   \\item{\\code{parM0}}{the estimates of null model.}\n#'   \\item{\\code{parM1}}{the estimates of alternative model.}\n#'   \\item{\\code{alpha}}{numeric: significance level.}\n#'   \\item{\\code{DIFitems}}{either the column indicators of the items which were detected as DIF, or \\code{\"No DIF item detected\"}.}\n#'   \\item{\\code{type}}{character: type of DIF that was tested.}\n#'   \\item{\\code{p.adjust.method}}{character: method for multiple comparison correction which was applied.}\n#'   \\item{\\code{pval}}{the p-values by likelihood ratio test.}\n#'   \\item{\\code{adj.pval}}{the adjusted p-values by likelihood ratio test using \\code{p.adjust.method}.}\n#'   \\item{\\code{df}}{the degress of freedom of likelihood ratio test.}\n#'   \\item{\\code{group}}{the vector of group membership.}\n#'   \\item{\\code{Data}}{the data matrix.}\n#' }\n#'\n#' @author\n#' Adela Drabinova \\cr\n#' Institute of Computer Science, The Czech Academy of Sciences \\cr\n#' Faculty of Mathematics and Physics, Charles University \\cr\n#' adela.drabinova@gmail.com \\cr\n#'\n#' Patricia Martinkova \\cr\n#' Institute of Computer Science, The Czech Academy of Sciences \\cr\n#' martinkova@cs.cas.cz \\cr\n#'\n#' Karel Zvara \\cr\n#' Faculty of Mathematics and Physics, Charles University \\cr\n#'\n#' @references\n#' Drabinova, A. and Martinkova P. (2016). Detection of Differenctial Item Functioning Based on Non-Linear Regression, Technical Report, V-1229, \\url{http://hdl.handle.net/11104/0259498}.\n#'\n#' Swaminathan, H. and Rogers, H. J. (1990). Detecting Differential Item Functioning Using Logistic Regression Procedures. Journal of Educational Measurement, 27, 361-370.\n#'\n#' @seealso \\code{\\link[stats]{p.adjust}}\n#'\n#' @examples\n#' \\dontrun{\n#' # loading data based on GMAT\n#' data(GMAT)\n#'\n#' Data  <- GMAT[, colnames(GMAT) != \"group\"]\n#' group <- GMAT[, \"group\"]\n#'\n#' # Testing both DIF effects using likelihood-ratio test and\n#' # 3PL model with fixed guessing for groups\n#' x <- difNLR(Data, group, focal.name = 1, model = \"3PLcg\")\n#'\n#' # Testing both DIF effects using F test and\n#' # 3PL model with fixed guessing for groups\n#' difNLR(Data, group, focal.name = 1, model = \"3PLcg\", test = \"F\")\n#'\n#' # Testing both DIF effects using LR test,\n#' # 3PL model with fixed guessing for groups\n#' # and Benjamini-Hochberg correction\n#' difNLR(Data, group, focal.name = 1, model = \"3PLcg\", p.adjust.method = \"BH\")\n#'\n#' # Testing both DIF effects using Rasch model\n#' difNLR(Data, group, focal.name = 1, model = \"Rasch\")\n#'\n#' # Testing both DIF effects using 2PL model\n#' difNLR(Data, group, focal.name = 1, model = \"2PL\")\n#'\n#' # Testing uniform DIF effects\n#' difNLR(Data, group, focal.name = 1, model = \"2PL\", type = \"udif\")\n#' # Testing non-uniform DIF effects\n#' difNLR(Data, group, focal.name = 1, model = \"2PL\", type = \"nudif\")\n#'\n#' # Graphical devices\n#' plot(x)\n#' plot(x, item = x$DIFitems)\n#' plot(x, plot.type = \"stat\")\n#'\n#' # Fitted values\n#' fitted(x)\n#' fitted(x, item = 1)\n#' # Predicted values\n#' predict(x)\n#' predict(x, item = 1)\n#'\n#' # Predicted values for new subjects\n#' predict(x, item = 1, score = 0, group = 1)\n#' predict(x, item = 1, score = 0, group = 0)\n#' }\n#' @keywords DIF\n#' @export\n\n\ndifNLR <- function(Data, group, focal.name, model,\n                   type = \"both\",\n                   test = \"LR\", alpha = 0.05,\n                   p.adjust.method = \"none\", start\n                   )\n{\n  if (type == \"nudif\" & model == \"1PL\")\n    stop(\"Detection of non-uniform DIF is not possible with 1PL model!\",\n         call. = FALSE)\n  if (type == \"nudif\" & model == \"Rasch\")\n    stop(\"Detection of non-uniform DIF is not possible with Rasch model!\",\n         call. = FALSE)\n  if (!type %in% c(\"udif\", \"nudif\", \"both\") | !is.character(type))\n    stop(\"'type' must be either 'udif', 'nudif' or 'both'\",\n         call. = FALSE)\n  if (!test %in% c(\"F\", \"LR\") | !is.character(type))\n    stop(\"'test' must be either 'F' or 'LR'\",\n         call. = FALSE)\n  if (alpha > 1 | alpha < 0)\n    stop(\"'alpha' must be between 0 and 1\",\n         call. = FALSE)\n  if (missing(start)) {\n    start <- NULL\n  }\n  if (missing(model)) {\n    stop(\"'model' is missing\",\n         call. = FALSE)\n  } else {\n    if (!(model %in% c(\"Rasch\", \"1PL\", \"2PL\", \"3PLcg\", \"3PLdg\", \"4PLcgdg\"))){\n      stop(\"Invalid value for 'model'\",\n           call. = FALSE)\n    }\n  }\n  internalNLR <- function() {\n    if (length(group) == 1) {\n      if (is.numeric(group)) {\n        GROUP <- Data[, group]\n        DATA <- Data[, (1:ncol(Data)) != group]\n        colnames(DATA) <- colnames(Data)[(1:ncol(Data)) !=  group]\n      } else {\n        GROUP <- Data[, colnames(Data) == group]\n        DATA <- Data[, colnames(Data) != group]\n        colnames(DATA) <- colnames(Data)[colnames(Data) !=  group]\n      }\n    } else {\n      GROUP <- group\n      DATA <- Data\n    }\n    if (length(levels(as.factor(GROUP))) != 2)\n      stop(\"'group' must be binary vector\", call. = FALSE)\n    if (is.matrix(DATA) | is.data.frame(DATA)) {\n      if (!all(apply(DATA, 2, function(i) {\n        length(levels(as.factor(i))) == 2\n      })))\n        stop(\"'Data' must be data frame or matrix of binary vectors\",\n             call. = FALSE)\n      if (nrow(DATA) != length(GROUP))\n        stop(\"'Data' must have the same number of rows as is length of vector 'group'\",\n             call. = FALSE)\n    } else {\n      stop(\"'Data' must be data frame or matrix of binary vectors\",\n           call. = FALSE)\n    }\n\n    GROUP <- as.numeric(as.factor(GROUP) == focal.name)\n    if (is.null(start)) {\n      start <- startNLR(DATA, GROUP, model)\n      # start <- switch(type,\n      #                 both = start,\n      #                 nudif = start,\n      #                 udif = start[, -4])\n\n    } else {\n      if (ncol(start) != 5 & type != \"udif\")\n        stop(\"'start' must be data frame or matrix with 5 columns\",\n             call. = FALSE)\n      if (ncol(start) != 4 & type == \"udif\")\n        stop(\"'start' must be data frame or matrix with 4 columns for detecting uniform DIF\",\n             call. = FALSE)\n      if (nrow(start) != ncol(Data))\n        stop(\"'start' must be data frame or matrix with starting values for each item\",\n             call. = FALSE)\n    }\n\n    PROV <- NLR(DATA, GROUP, model = model, type = type, start = start,\n                p.adjust.method = p.adjust.method, test = test,\n                alpha = alpha)\n    STATS <- PROV$Sval\n    ADJ.PVAL <- PROV$adjusted.pval\n    significant <- which(ADJ.PVAL < alpha)\n    if (length(significant) > 0) {\n      DIFitems <- significant\n      nlrPAR <- nlrSE <- structure(data.frame(matrix(0, ncol = ncol(PROV$par.m0), nrow = nrow(PROV$par.m0))),\n                                   .Names = colnames(PROV$par.m0))\n\n      nlrPAR[, colnames(PROV$par.m1)] <- PROV$par.m1\n      nlrSE[, colnames(PROV$par.m1)] <- PROV$se.m1\n\n      for (idif in 1:length(DIFitems)) {\n        nlrPAR[DIFitems[idif], ] <- PROV$par.m0[DIFitems[idif], ]\n        nlrSE[DIFitems[idif], ] <- PROV$se.m0[DIFitems[idif], ]\n      }\n\n    } else {\n      DIFitems <- \"No DIF item detected\"\n      nlrPAR <- PROV$par.m1\n      nlrSE <- PROV$se.m1\n    }\n\n\n    RES <- list(Sval = STATS,\n                nlrPAR = nlrPAR, nlrSE = nlrSE,\n                parM0 = PROV$par.m0, seM0 = PROV$se.m0, covM0 = PROV$cov.m0,\n                parM1 = PROV$par.m1, seM1 = PROV$se.m1, covM1 = PROV$cov.m1,\n                alpha = alpha, DIFitems = DIFitems,\n                model = model,\n                type = type, p.adjust.method = p.adjust.method,\n                pval = PROV$pval, adj.pval = PROV$adjusted.pval, df = PROV$df,\n                adjusted.p = NULL, test = test,\n                group = GROUP, Data = DATA,\n                conv.fail = PROV$conv.fail, conv.fail.which = PROV$conv.fail.which)\n    # , thr = Q\n    class(RES) <- \"difNLR\"\n    return(RES)\n  }\n\n\n  resToReturn <- internalNLR()\n  return(resToReturn)\n}\n\n\n#' @rdname difNLR\n#' @export\nprint.difNLR <- function (x, ...){\n  title <- switch(x$type,\n                  both = \"Detection of both types of Differential Item Functioning using Generalized Logistic Regression Model\",\n                  udif = \"Detection of uniform Differential Item Functioning using Generalized Logistic Regression Model\",\n                  nudif = \"Detection of non-uniform Differential Item Functioning using Generalized Logistic Regression Model\")\n  cat(paste(strwrap(title, width = 60), collapse = \"\\n\"))\n  cat(paste(switch(x$test,\n                   \"F\" = \"\\n\\nGeneralized Logistic Regression F-test statistics based on\",\n                   \"LR\" = \"\\n\\nGeneralized Logistic Regression Likelihood Ratio chi-square statistics based on\\n\"),\n            switch(x$model,\n                   \"Rasch\" = \"Rasch model\", \"1PL\" = \"1PL model\", \"2PL\" = \"2PL model\",\n                   \"3PL\" = \"3PL model\", \"3PLcg\" = \"3PL model with fixed guessing for groups\",\n                   \"3PLdg\" = \"3PL model with fixed inattention parameter for groups\",\n                   \"3PLc\" = \"3PL model\", \"3PLd\" = \"3PL model with inattention parameter\",\n                   \"4PLcgdf\" = \"4PL model with fixed guessing and inattention parameter for groups\",\n                   \"4PLcg\" = \"4PL model with fixed guessing for groups\",\n                   \"4PLdg\" = \"4PL model with fixed inattention parameter for groups\",\n                   \"4PL\" = \"4PL model\")), \"\\n\")\n  if (x$p.adjust.method == \"none\") {\n    cat(\"No p-value adjustment for multiple comparisons\\n\\n\")\n  }\n  else {\n    cat(paste(\"Multiple comparisons made with\",\n              switch(x$p.adjust.method,\n                     holm = \"Holm\", hochberg = \"Hochberg\", hommel = \"Hommel\",\n                     bonferroni = \"Bonferroni\", BH = \"Benjamini-Hochberg\",\n                     BY = \"Benjamini-Yekutieli\", fdr = \"FDR\"), \"adjustment of p-values\\n\\n\"))\n  }\n  sign <- ifelse(is.na(x$adj.pval), \" \",\n                 ifelse(x$adj.pval < 0.001, \"***\",\n                        ifelse(x$adj.pval < 0.01, \"**\",\n                               ifelse(x$adj.pval < 0.05, \"*\",\n                                      ifelse(x$adj.pval < 0.1, \".\", \" \")))))\n  if (x$p.adjust.method == \"none\"){\n    tab <- format(round(cbind(x$Sval, x$pval), 4))\n    tab <- matrix(cbind(tab, sign), ncol = 3)\n    colnames(tab) <- switch(x$test,\n                            \"F\" = c(\"F-value\", \"P-value\", \"\"),\n                            \"LR\" = c(\"Chisq-value\", \"P-value\", \"\"))\n  } else {\n    tab <- format(round(cbind(x$Sval, x$pval, x$adj.pval), 4))\n    tab <- matrix(cbind(tab, sign), ncol = 4)\n    colnames(tab) <- switch(x$test,\n                            \"F\" = c(\"F-value\", \"P-value\", \"Adj. P-value\", \"\"),\n                            \"LR\" = c(\"Chisq-value\", \"P-value\", \"Adj. P-value\", \"\"))\n  }\n\n  rownames(tab) <- paste(\"Item\", 1:length(x$adj.pval))\n\n  print(tab, quote = F, digits = 4, zero.print = F)\n  cat(\"\\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\\n\")\n\n  critical <- ifelse(x$test == \"F\", qf(1 - x$alpha, x$df[1], x$df[2]), qchisq(1 - x$alpha, x$df))\n  cat(paste(\"\\nDetection thresholds: \", round(critical, 4), \" (significance level: \", x$alpha, \")\", sep = \"\"))\n  if (is.character(x$DIFitems)) {\n    switch(x$type, both = cat(\"\\nNone of items is detected as DIF\"),\n           udif = cat(\"\\nNone of items is detected as uniform DIF\"),\n           nudif = cat(\"\\nNone of items is detected as non-uniform DIF\"))\n  }\n  else {\n    switch(x$type, both = cat(\"\\n\\nItems detected as DIF items:\"),\n           udif = cat(\"\\n\\nItems detected as uniform DIF items:\"),\n           nudif = cat(\"\\n\\nItems detected as non-uniform DIF items:\"))\n    cat(\"\\n\", paste(\"Item \", x$DIF, \"\\n\", sep = \"\"))\n  }\n}\n\n#' @rdname difNLR\n#' @export\nplot.difNLR <- function(x, plot.type = \"cc\", item = \"all\",\n                        col = c(\"dodgerblue2\", \"goldenrod2\"),\n                        shape = 21, size = .8,\n                        linetype = c(2, 1), title,\n                        ...){\n\n  plotstat <- function(x, size = size, title = title){\n    if (x$conv.fail != 0){\n      if (length(x$conv.fail) == length(x$Sval)){\n        switch(x$test, \"F\" = stop(\"None of items does converge.\n                                  F-statistic values not plotted\", call. = FALSE),\n                       \"LR\" = stop(\"None of items does converge.\n                                   LR-statistic values not plotted\", call. = FALSE))\n      } else {\n        switch(x$test, \"F\" = warning(paste(\"Item \", x$conv.fail.which,\n                                           \" does not converge. F-statistic value not plotted\",\n                                           sep = \"\", collapse = \"\\n\"), call. = FALSE),\n                       \"LR\" = warning(paste(\"Item \", x$conv.fail.which,\n                                            \" does not converge. LR-statistic value not plotted\",\n                                           sep = \"\", collapse = \"\\n\"), call. = FALSE))\n      }\n    }\n\n    if(missing(title)){\n      title <- \"Non-Linear Regression DIF Detection \\n with None Multiple Comparison Correction\"\n    }\n    n <- nrow(x$Data)\n    Sval_critical <- switch(x$test,\n                            \"F\" = qf(1 - x$alpha, x$df[1], x$df[2]),\n                            \"LR\" = qchisq(1 - x$alpha, x$df))\n    g <- as.factor(ifelse(x$Sval > Sval_critical, 1, 0))\n    items <- setdiff(1:length(x$Sval), x$conv.fail.which)\n    hv <- na.omit(as.data.frame(cbind(1:length(x$Sval), x$Sval, g)))\n    plot_stat <- ggplot(hv, aes_string(x = \"V1\", y = \"V2\",\n                                       label = as.character(\"V1\"),\n                                       col = as.factor(g))) +\n                  ### points\n                  geom_text() +\n                  scale_color_manual(values = c(\"black\", \"red\")) +\n                  ### critical value\n                  geom_hline(yintercept = Sval_critical, size = size) +\n                  ### theme\n                  ggtitle(title) +\n                  labs(x = \"Item\", y = switch(x$test,\n                                              \"F\" = \"F-statistic\",\n                                              \"LR\" = \"Chisq-statistic\")) +\n                  theme_bw() +\n                  theme(text = element_text(size = 11),\n                        plot.title = element_text(size = 11, face = \"bold\", vjust = 1.5),\n                        axis.line  = element_line(colour = \"black\"),\n                        panel.grid.major = element_blank(),\n                        panel.grid.minor = element_blank(),\n                        plot.background = element_rect(fill = \"transparent\", colour = NA),\n                        axis.text.x = element_blank(),\n                        axis.ticks.x = element_blank(),\n                        legend.position = \"none\")\n\n    print(plot_stat)\n  }\n\n  plotCC <- function(x, item = item,\n                     col = col, shape = shape, size = size,\n                     linetype = linetype, title = title){\n    m <- nrow(x$nlrPAR)\n    if (class(item) == \"character\"){\n      if (item != \"all\")\n        stop(\"'item' must be either numeric vector or character string 'all' \",\n             call. = FALSE)\n    } else {\n      if (class(item) != \"integer\" & class(item) != \"numeric\")\n        stop(\"'item' must be either numeric vector or character string 'all' \",\n             call. = FALSE)\n    }\n    if (class(item) == \"numeric\" & !all(item %in% 1:m))\n      stop(\"invalid number of 'item'\",\n           call. = FALSE)\n    if (class(item) == \"integer\" & !all(item %in% 1:m))\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n    if (length(col) == 1){\n      col <- rep(col, 2)\n    } else {\n      if (length(col) > 2){\n        col <- col[1:2]\n        warning(\"Length of 'col' is greater than 2. Only first two values are used\",\n                call. = FALSE)\n      }\n    }\n    if (class(item) == \"character\"){\n      items <- 1:m\n    } else {\n      items <- item\n    }\n    if (any(x$conv.fail.which %in% items)){\n      if (length(setdiff(items, x$conv.fail.which)) == 0){\n        stop(paste(\"Item \", intersect(x$conv.fail.which, items), \" does not converge. Characteristic curve not plotted\",\n                   sep = \"\", collapse = \"\\n\"),\n             call. = FALSE)\n      } else {\n        warning(paste(\"Item \", intersect(x$conv.fail.which, items), \" does not converge. Characteristic curve not plotted\",\n                      sep = \"\", collapse = \"\\n\"),\n                call. = FALSE)\n        items <- setdiff(items, x$conv.fail.which)\n      }\n    }\n    if (length(linetype) != 2){\n      if (length(linetype) == 1){\n        linetype <- rep(linetype, 2)\n      } else {\n        linetype <- linetype[1:2]\n        warning(\"Length of 'linetype' is greater than 2. Only first two values are used\",\n                call. = FALSE)\n      }\n    }\n    if (!missing(title)){\n      TITLE <- title\n    }\n\n    ### functions\n    gNLR <- deriv3( ~ (c + cDif * g) + ((d + dDif * g) - (c + cDif * g)) /\n                      (1 + exp(-(a + aDif * g) * (x - (b + bDif * g)))),\n                    namevec = c(\"a\", \"b\", \"c\", \"d\", \"aDif\", \"bDif\", \"cDif\", \"dDif\"),\n                    function.arg = function(x, g, a, b, c, d, aDif, bDif, cDif, dDif){})\n\n    ### Data\n    xR <- c(scale(apply(x$Data[x$group == 0, ], 1, sum)))\n    xF <- c(scale(apply(x$Data[x$group == 1, ], 1, sum)))\n    max_sts <- max(as.numeric(levels(as.factor(xR))),\n                   as.numeric(levels(as.factor(xF))))\n    min_sts <- min(as.numeric(levels(as.factor(xR))),\n                   as.numeric(levels(as.factor(xF))))\n    alpha <- 0.5\n    plot_CC <- list()\n\n    for (i in items){\n      hv_R <- data.frame(cbind(as.numeric(levels(as.factor(xR))),\n                               tapply(x$Data[x$group == 0, i],\n                                      as.factor(xR), mean)))\n      hv_F <- data.frame(cbind(as.numeric(levels(as.factor(xF))),\n                               tapply(x$Data[x$group == 1, i],\n                                      as.factor(xF), mean)))\n      hv   <- data.frame(rbind(cbind(hv_R, Group = \"Reference\"),\n                               cbind(hv_F, Group = \"Focal\")))\n      rownames(hv) <- 1:dim(hv)[1]\n      hv$size <- c(table(xR), table(xF))\n\n      if (missing(title)){\n        TITLE <- paste(\"Item\", i)\n      }\n\n      if (dim(x$nlrPAR)[2] != 8){\n        PAR <- data.frame(a = rep(1, m), b = 0, c = 0, d = 1, aDif = 0, bDif = 0, cDif = 0, dDif = 0)\n        PAR[, colnames(x$nlrPAR)] <- x$nlrPAR\n      } else {\n        PAR <- x$nlrPAR\n      }\n      plot_CC[[i]] <- ggplot(hv, aes_string(\"X1\", \"X2\")) +\n                      ### points\n                      geom_point(aes_string(colour = \"Group\", fill = \"Group\",\n                                            size = \"size\"),\n                                 alpha = alpha, shape = shape) +\n                      ### lines\n                      stat_function(aes(colour = \"Reference\", linetype = \"Reference\"),\n                                    fun = gNLR,\n                                    args = list(g = 0,\n                                                a = PAR[i, \"a\"], b = PAR[i, \"b\"],\n                                                c = PAR[i, \"c\"], d = PAR[i, \"d\"],\n                                                aDif = PAR[i, \"aDif\"], bDif = PAR[i, \"bDif\"],\n                                                cDif = PAR[i, \"cDif\"], dDif = PAR[i, \"dDif\"]),\n                                    size = size,\n                                    geom = \"line\") +\n                      stat_function(aes(colour = \"Focal\", linetype = \"Focal\"),\n                                    fun = gNLR,\n                                    args = list(g = 1,\n                                                a = PAR[i, \"a\"], b = PAR[i, \"b\"],\n                                                c = PAR[i, \"c\"], d = PAR[i, \"d\"],\n                                                aDif = PAR[i, \"aDif\"], bDif = PAR[i, \"bDif\"],\n                                                cDif = PAR[i, \"cDif\"], dDif = PAR[i, \"dDif\"]),\n                                    size = size,\n                                    geom = \"line\") +\n                      ### style\n                      scale_size_continuous(name = \"Counts\")  +\n                      scale_colour_manual(breaks = hv$Group, values = col, name = \"Group\") +\n                      scale_fill_manual(breaks = hv$Group, values = col, name = \"Group\") +\n                      scale_linetype_manual(breaks = hv$Group, values = linetype, name = \"Group\") +\n                      ### theme\n                      ggtitle(TITLE) +\n                      labs(x = \"Standardized total score\", y = \"Probability of correct answer\") +\n                      scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +\n                      theme_bw() +\n                      theme(text = element_text(size = 11),\n                            plot.title = element_text(size = 11, face = \"bold\", vjust = 1.5),\n                            axis.line  = element_line(colour = \"black\"),\n                            panel.grid.major = element_blank(),\n                            panel.grid.minor = element_blank(),\n                            plot.background = element_rect(fill = \"transparent\", colour = NA)) +\n                      ### legend\n                      theme(legend.box.just = \"left\",\n                            legend.justification = c(1, 0),\n                            legend.position = c(0.97, 0.03),\n                            # legend.margin = margin(0, \"lines\"),\n                            legend.box = \"vertical\",\n                            # legend.key.size = unit(0.9, \"cm\"),\n                            # legend.key.height = unit(0.8, \"line\"),\n                            legend.text.align = 0,\n                            legend.title.align = 0,\n                            legend.key = element_rect(colour = \"white\"))\n    }\n\n    plot_CC <- Filter(Negate(function(i) is.null(unlist(i))), plot_CC)\n    # names(plot_CC) <- paste(\"Item\", items)\n    # class(plot_CC)\n\n    return(plot_CC)\n  }\n  ### checking input\n  if (!(plot.type %in% c(\"cc\", \"stat\"))){\n    stop(\"Possible values of 'plot.type' is 'cc' or 'stat' \",\n         call. = FALSE)\n  } else {\n    if (plot.type == \"cc\"){\n      plotCC(x, item = item,\n             col = col, shape = shape, size = size,\n             linetype = linetype, title = title)\n    } else {\n      plotstat(x, size = size, title = title)\n    }\n  }\n}\n\n#' @rdname difNLR\n#' @export\nfitted.difNLR <- function(object, item = \"all\", ...){\n\n  ### checking input\n  m <- nrow(object$nlrPAR)\n  if (class(item) == \"character\"){\n    if (item != \"all\")\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n  } else {\n    if (class(item) != \"integer\" & class(item) != \"numeric\")\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n  }\n  if (class(item) == \"numeric\" & !all(item %in% 1:m))\n    stop(\"invalid number of 'item'\",\n         call. = FALSE)\n  if (class(item) == \"integer\" & !all(item %in% 1:m))\n    stop(\"'item' must be either numeric vector or character string 'all' \",\n         call. = FALSE)\n  if (class(item) == \"character\"){\n    items <- 1:m\n  } else {\n    items <- item\n  }\n  if (any(object$conv.fail.which %in% items)){\n    if (length(setdiff(items, object$conv.fail.which)) == 0){\n      stop(paste(\"Item \", intersect(object$conv.fail.which, items), \" does not converge. No values displayed\",\n                 sep = \"\", collapse = \"\\n\"),\n           call. = FALSE)\n    } else {\n      warning(paste(\"Item \", intersect(object$conv.fail.which, items), \" does not converge. No values displayed\",\n                    sep = \"\", collapse = \"\\n\"),\n              call. = FALSE)\n      items <- setdiff(items, object$conv.fail.which)\n    }\n  }\n\n\n  ### functions\n  gNLR <- function(x, g, a, b, c, d, aDif, bDif, cDif, dDif){\n    return((c + cDif * g) + ((d + dDif * g) - (c + cDif * g)) / (1 + exp(-(a + aDif * g) * (x - (b + bDif * g)))))\n  }\n\n  if (dim(object$nlrPAR)[2] != 8){\n    PAR <- data.frame(a = rep(1, m), b = 0, c = 0, d = 1, aDif = 0, bDif = 0, cDif = 0, dDif = 0)\n    PAR[, colnames(object$nlrPAR)] <- object$nlrPAR\n  } else {\n    PAR <- object$nlrPAR\n  }\n  ### data\n  STS <- c(scale(apply(object$Data, 1, sum)))\n\n  ### fitted values\n  FV <- lapply(items, function(i) gNLR(STS, object$group, PAR[i, \"a\"], PAR[i, \"b\"],\n                                       PAR[i, \"c\"], PAR[i, \"d\"],\n                                       PAR[i, \"aDif\"], PAR[i, \"bDif\"],\n                                       PAR[i, \"cDif\"], PAR[i, \"dDif\"]))\n  FV <- lapply(FV, setNames, NULL)\n  names(FV) <- paste(\"Item\", items)\n  return(FV)\n\n}\n\n#' @rdname difNLR\n#' @export\npredict.difNLR <- function(object, item = \"all\",\n                           score, group, ...){\n\n  ### checking input\n  m <- nrow(object$nlrPAR)\n  if (class(item) == \"character\"){\n    if (item != \"all\")\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n  } else {\n    if (class(item) != \"integer\" & class(item) != \"numeric\")\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n  }\n  if (class(item) == \"numeric\" & !all(item %in% 1:m))\n    stop(\"invalid number of 'item'\",\n         call. = FALSE)\n  if (class(item) == \"integer\" & !all(item %in% 1:m))\n    stop(\"'item' must be either numeric vector or character string 'all' \",\n         call. = FALSE)\n  if (missing(score)){\n    score <- c(scale(apply(object$Data, 1, sum)))\n  }\n  if (missing(group)){\n    group <- object$group\n  }\n  if(length(score) != length(group)){\n    stop(\"'score' and 'group' must be the same length\",\n         call. = FALSE)\n  }\n  if (class(item) == \"character\"){\n    items <- 1:m\n  } else {\n    items <- item\n  }\n  if (any(object$conv.fail.which %in% items)){\n    if (length(setdiff(items, object$conv.fail.which)) == 0){\n      stop(paste(\"Item \", intersect(object$conv.fail.which, items), \" does not converge. No values displayed\",\n                 sep = \"\", collapse = \"\\n\"),\n           call. = FALSE)\n    } else {\n      warning(paste(\"Item \", intersect(object$conv.fail.which, items), \" does not converge. No values displayed\",\n                    sep = \"\", collapse = \"\\n\"),\n              call. = FALSE)\n      items <- setdiff(items, object$conv.fail.which)\n    }\n  }\n\n  ### functions\n  gNLR <- function(x, g, a, b, c, d, aDif, bDif, cDif, dDif){\n    return((c + cDif * g) + ((d + dDif * g) - (c + cDif * g)) / (1 + exp(-(a + aDif * g) * (x - (b + bDif * g)))))\n  }\n\n\n  if (dim(object$nlrPAR)[2] != 8){\n    PAR <- data.frame(a = rep(1, m), b = 0, c = 0, d = 1, aDif = 0, bDif = 0, cDif = 0, dDif = 0)\n    PAR[, colnames(object$nlrPAR)] <- object$nlrPAR\n  } else {\n    PAR <- object$nlrPAR\n  }\n  ### data\n  STS <- score\n\n\n  ### predicted values\n  PV <- lapply(items, function(i) NLR(STS, group, PAR[i, \"a\"], PAR[i, \"b\"],\n                                      PAR[i, \"c\"], PAR[i, \"d\"],\n                                      PAR[i, \"aDif\"], PAR[i, \"bDif\"],\n                                      PAR[i, \"cDif\"], PAR[i, \"dDif\"]))\n  PV <- lapply(PV, setNames, NULL)\n  names(PV) <- paste(\"Item\", items)\n  return(predict = PV)\n}\n\n#' @rdname difNLR\n#' @export\ncoef.difNLR <- function(object, ...){\n  return(object$nlrPAR)\n}\n",
    "created" : 1482141533690.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2162915545",
    "id" : "48EE7A3",
    "lastKnownWriteTime" : 1483368204,
    "last_content_update" : -2147483648,
    "path" : "U:/difNLR/R/difNLR.R",
    "project_path" : "R/difNLR.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}