{
    "collab_server" : "",
    "contents" : "#' Performs DDF detection using Multinomial Log-linear Regression model.\n#'\n#' @aliases ddfMLR print.ddfMLR plot.ddfMR\n#'\n#' @description Performs DDF detection procedure based on Multinomial Log-linear Regression model and\n#' likelihood ratio test of submodel.\n#'\n#' @param Data character: either the unscored data matrix only, or the unscored data\n#' matrix plus the vector of group. See \\strong{Details}.\n#' @param group numeric or character: either the binary vector of group membership or\n#' the column indicator of group membership. See \\strong{Details}.\n#' @param focal.name numeric or character: indicated the level of \\code{group} which corresponds to\n#' focal group\n#' @param key character: the answer key. See \\strong{Details}.\n#' @param type character: type of DIF to be tested (either \"both\" (default), \"udif\", or \"nudif\").\n#' See \\strong{Details}.\n#' @param p.adjust.method character: method for multiple comparison correction.\n#' See \\strong{Details}.\n#' @param alpha numeric: significance level (default is 0.05).\n#' @param x an object of 'ddfMLR' class\n#' @param item either character (\"all\"), or numeric vector, or single number\n#'corresponding to column indicators. See \\strong{Details}.\n#' @param title string: title of plot.\n#' @param ... other generic parameters for \\code{print} or \\code{plot} functions.\n#'\n#' @usage ddfMLR(Data, group, focal.name, key, type = \"both\",\n#' alpha = 0.05, p.adjust.method = \"none\")\n#'\n#' @details\n#' DDF detection procedure based on Multinomial Log-linear model.\n#'\n#' The \\code{Data} is a matrix whose rows represents examinee unscored answers and\n#' columns correspond to the items. The \\code{group} must be either a vector of the same\n#' length as \\code{nrow(data)} or column indicator of \\code{Data}. The \\code{key} must be\n#' a vector of correct answers corresponding to columns of \\code{Data}.\n#'\n#' The \\code{type} corresponds to type of DIF to be tested. Possible values are \\code{\"both\"}\n#' to detect any DIF (uniform and/or non-uniform), \\code{\"udif\"} to detect only uniform DIF or\n#' \\code{\"nudif\"} to detect only non-uniform DIF.\n#'\n#' The \\code{p.adjust.method} is a character for \\code{p.adjust} function from the\n#' \\code{stats} package. Possible values are \\code{\"holm\"}, \\code{\"hochberg\"},\n#' \\code{\"hommel\"}, \\code{\"bonferroni\"}, \\code{\"BH\"}, \\code{\"BY\"}, \\code{\"fdr\"}, \\code{\"none\"}.\n#'\n#' The output of the ddfMLR is displayed by the \\code{print.ddfMLR} function.\n#'\n#' The characteristic curve for item specified in \\code{item} option can be plotted. For default\n#' option \\code{\"all\"} of item, characteristic curves of all converged items are plotted.\n#' The drawn curves represent best model.\n#'\n#' Fitted values are extracted by the \\code{fitted.difNLR} function for item(s) specified in\n#' \\code{item} argument.\n#'\n#' Predicted values are produced by the \\code{predict.difNLR} function for item(s) specified in\n#' \\code{item} argument. \\code{score} represents standardized total score of new subject and\n#' \\code{group} argument represents group membership of new subject.\n#'\n#' Missing values are allowed but discarded for item estimation. They must be coded as \\code{NA}\n#' for both, \\code{data} and \\code{group} parameters.\n#'\n#' @return A list of class 'difNLR' with the following arguments:\n#' \\describe{\n#'   \\item{\\code{Sval}}{the values of likelihood ratio test statistics.}\n#'   \\item{\\code{nlrPAR}}{the estimates of final model.}\n#'   \\item{\\code{parM0}}{the estimates of null model.}\n#'   \\item{\\code{parM1}}{the estimates of alternative model.}\n#'   \\item{\\code{alpha}}{numeric: significance level.}\n#'   \\item{\\code{DDFitems}}{either the column indicators of the items which were detected as DDF, or \\code{\"No DDF item detected\"}.}\n#'   \\item{\\code{type}}{character: type of DIF that was tested.}\n#'   \\item{\\code{p.adjust.method}}{character: method for multiple comparison correction which was applied.}\n#'   \\item{\\code{pval}}{the p-values by likelihood ratio test.}\n#'   \\item{\\code{adj.pval}}{the adjusted p-values by likelihood ratio test using \\code{p.adjust.method}.}\n#'   \\item{\\code{df}}{the degress of freedom of likelihood ratio test.}\n#'   \\item{\\code{group}}{the vector of group membership.}\n#'   \\item{\\code{Data}}{the data matrix.}\n#'   }\n#'\n#' @author\n#' Adela Drabinova \\cr\n#' Institute of Computer Science, The Czech Academy of Sciences \\cr\n#' Faculty of Mathematics and Physics, Charles University \\cr\n#' adela.drabinova@gmail.com \\cr\n#'\n#' Patricia Martinkova \\cr\n#' Institute of Computer Science, The Czech Academy of Sciences \\cr\n#'\n#' @seealso \\code{\\link[stats]{p.adjust}}\n#'\n#' @examples\n#' \\dontrun{\n#' # loading data based on GMAT\n#' data(GMATtest, GMATkey)\n#'\n#' Data  <- GMATtest[, colnames(GMATtest) != \"group\"]\n#' group <- GMATtest[, \"group\"]\n#' key <- GMATkey\n#'\n#' # Testing both DIF effects\n#' x <- ddfMLR(Data, group, focal.name = 1, key)\n#'\n#' # Testing both DIF effects with Benjamini-Hochberg adjustment method\n#' ddfMLR(Data, group, focal.name = 1, key, type = \"both\", p.adjust.method = \"BH\")\n#'\n#' # Testing uniform DIF effects\n#' ddfMLR(Data, group, focal.name = 1, key, type = \"udif\")\n#' # Testing non-uniform DIF effects\n#' ddfMLR(Data, group, focal.name = 1, key, type = \"nudif\")\n#'\n#' # Graphical devices\n#' plot(x, item = 1)\n#' plot(x, item = x$DDFitems)\n#' plot(x, item = \"all\")\n#' }\n#' @keywords DDF\n#' @export\n#' @importFrom reshape2 melt\n#' @importFrom stats relevel\n\nddfMLR <- function(Data, group, focal.name, key, type = \"both\",\n                alpha = 0.05,\n                p.adjust.method = \"none\")\n{\n  if (!type %in% c(\"udif\", \"nudif\", \"both\") | !is.character(type))\n    stop(\"'type' must be either 'udif', 'nudif' or 'both'\",\n         call. = FALSE)\n  if (alpha > 1 | alpha < 0)\n    stop(\"'alpha' must be between 0 and 1\",\n         call. = FALSE)\n  internalMLR <- function() {\n    if (length(group) == 1) {\n      if (is.numeric(group)) {\n        GROUP <- Data[, group]\n        DATA <- Data[, (1:ncol(Data)) != group]\n        colnames(DATA) <- colnames(Data)[(1:ncol(Data)) !=  group]\n      } else {\n        GROUP <- Data[, colnames(Data) == group]\n        DATA <- Data[, colnames(Data) != group]\n        colnames(DATA) <- colnames(Data)[colnames(Data) !=  group]\n      }\n    } else {\n      GROUP <- group\n      DATA <- Data\n    }\n    if (length(levels(as.factor(GROUP))) != 2)\n      stop(\"'group' must be binary vector\", call. = FALSE)\n    if (is.matrix(DATA) | is.data.frame(DATA)) {\n      if (nrow(DATA) != length(GROUP))\n        stop(\"'Data' must have the same number of rows as is length of vector 'group'\",\n             call. = FALSE)\n    } else {\n      stop(\"'Data' must be data frame or matrix of binary vectors\",\n           call. = FALSE)\n    }\n    if (length(key) != ncol(DATA)){\n      stop(\"Number of items in 'Data' is not equal to the length of 'key'.\",\n           call. = FALSE)\n    }\n\n    GROUP <- as.numeric(as.factor(GROUP) == focal.name)\n\n    PROV <- MLR(DATA, GROUP, key = key, type = type,\n                p.adjust.method = p.adjust.method,\n                alpha = alpha)\n    STATS <- PROV$Sval\n    ADJ.PVAL <- PROV$adjusted.pval\n    significant <- which(ADJ.PVAL < alpha)\n    if (length(significant) > 0) {\n      DDFitems <- significant\n      mlrPAR <- PROV$par.m1\n      # nlrSE <- PROV$se.m1\n      for (idif in 1:length(DDFitems)) {\n        mlrPAR[[DDFitems[idif]]] <- PROV$par.m0[[DDFitems[idif]]]\n        # nlrSE[[DDFitems[idif]]] <- PROV$se.m0[[DDFitems[idif]]]\n      }\n\n      # colnames(nlrPAR) <- colnames(nlrSE) <- switch(type,\n      #                                               \"both\" = c(\"a\", \"b\", \"c\", \"aDIF\", \"bDIF\"),\n      #                                               \"nudif\" = c(\"a\", \"b\", \"c\", \"aDIF\", \"bDIF\"),\n      #                                                \"udif\" = c(\"a\", \"b\", \"c\", \"bDIF\"))\n      } else {\n        DDFitems <- \"No DDF item detected\"\n        nlrPAR <- PROV$par.m1\n        # nlrSE <- PROV$se.m1\n      }\n\n\n    RES <- list(Sval = STATS,\n                mlrPAR = mlrPAR,\n                # nlrSE = nlrSE,\n                parM0 = PROV$par.m0,\n                # seM0 = PROV$se.m0, covM0 = PROV$cov.m0,\n                parM1 = PROV$par.m1,\n                # seM1 = PROV$se.m1, covM1 = PROV$cov.m1,\n                alpha = alpha, DDFitems = DDFitems,\n                type = type, p.adjust.method = p.adjust.method,\n                pval = PROV$pval, adj.pval = PROV$adjusted.pval, df = PROV$df,\n                adjusted.p = NULL,\n                group = GROUP, Data = DATA, key = key)\n\n    class(RES) <- \"ddfMLR\"\n    return(RES)\n  }\n  resToReturn <- internalMLR()\n  return(resToReturn)\n}\n\n\n#' @rdname ddfMLR\n#' @export\nprint.ddfMLR <- function (x, ...){\n  title <- switch(x$type,\n                  both = \"Detection of both types of Distractor Differential Functioning using Logistic Regression method\",\n                  udif = \"Detection of uniform Distractor Differential Functioning using Logistic Regression method\",\n                  nudif = \"Detection of non-uniform Distractor Differential Functioning using Logistic Regression method\")\n  cat(paste(strwrap(title, width = 60), collapse = \"\\n\"))\n  cat(\"\\n\\nLikelihood-ratio chi-square statistics\\n\")\n  if (x$p.adjust.method == \"none\") {\n    cat(\"No p-value adjustment for multiple comparisons\\n\\n\")\n  }\n  else {\n    cat(paste(\"Multiple comparisons made with\",\n              switch(x$p.adjust.method,\n                     holm = \"Holm\", hochberg = \"Hochberg\", hommel = \"Hommel\",\n                     bonferroni = \"Bonferroni\", BH = \"Benjamini-Hochberg\",\n                     BY = \"Benjamini-Yekutieli\", fdr = \"FDR\"), \"adjustment of p-values\\n\\n\"))\n  }\n  sign <- ifelse(is.na(x$adj.pval), \" \",\n                 ifelse(x$adj.pval < 0.001, \"***\",\n                        ifelse(x$adj.pval < 0.01, \"**\",\n                               ifelse(x$adj.pval < 0.05, \"*\",\n                                      ifelse(x$adj.pval < 0.1, \".\", \" \")))))\n  if (x$p.adjust.method == \"none\"){\n    tab <- format(round(cbind(x$Sval, x$pval), 4))\n    tab <- matrix(cbind(tab, sign), ncol = 3)\n    colnames(tab) <- c(\"Chisq-value\", \"P-value\", \"\")\n  } else {\n    tab <- format(round(cbind(x$Sval, x$pval, x$adj.pval), 4))\n    tab <- matrix(cbind(tab, sign), ncol = 4)\n    colnames(tab) <- c(\"Chisq-value\", \"P-value\", \"Adj. P-value\", \"\")\n  }\n\n  rownames(tab) <- paste(\"Item\", 1:length(x$adj.pval))\n\n  print(tab, quote = F, digits = 4, zero.print = F)\n  cat(\"\\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\\n\")\n\n  # critical <- ifelse(x$test == \"F\", qf(1 - x$alpha, x$df[1], x$df[2]), qchisq(1 - x$alpha, x$df))\n  # cat(paste(\"\\nDetection thresholds: \", round(critical, 4), \" (significance level: \", x$alpha, \")\", sep = \"\"))\n  if (is.character(x$DDFitems)) {\n    switch(x$type, both = cat(\"\\nNone of items is detected as DDF\"),\n           udif = cat(\"\\nNone of items is detected as uniform DDF\"),\n           nudif = cat(\"\\nNone of items is detected as non-uniform DDF\"))\n  }\n  else {\n    switch(x$type, both = cat(\"\\n\\nItems detected as DDF items:\"),\n           udif = cat(\"\\n\\nItems detected as uniform DDF items:\"),\n           nudif = cat(\"\\n\\nItems detected as non-uniform DDF items:\"))\n    cat(\"\\n\", paste(\"Item \", x$DDFitems, \"\\n\", sep = \"\"))\n  }\n}\n\n\n\n\n#' @rdname ddfMLR\n#' @export\nplot.ddfMLR <- function(x, item = \"all\", title, ...){\n  m <- length(x$mlrPAR)\n  if (class(item) == \"character\"){\n    if (item != \"all\")\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n  } else {\n    if (class(item) != \"integer\" & class(item) != \"numeric\")\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n  }\n  if (class(item) == \"numeric\" & !all(item %in% 1:m))\n    stop(\"invalid number of 'item'\",\n         call. = FALSE)\n  if (class(item) == \"integer\" & !all(item %in% 1:m))\n    stop(\"'item' must be either numeric vector or character string 'all' \",\n         call. = FALSE)\n\n  if (class(item) == \"character\"){\n    items <- 1:m\n  } else {\n    items <- item\n  }\n\n\n\n  score <- scale(unlist(score(x$Data, x$key)))\n  sq <- seq(min(score), max(score), by = 0.1)\n  sqR <- as.matrix(data.frame(1, sq, 0, 0))\n  sqF <- as.matrix(data.frame(1, sq, 1, sq))\n  plot_CC <- list()\n  for (i in items){\n\n    if (!missing(title)){\n      TITLE <- title\n    } else {\n      TITLE <- paste(\"Item\", i)\n    }\n\n    if(ncol(x$mlrPAR[[i]]) == 2)\n      x$mlrPAR[[i]] <- as.matrix(data.frame(x$mlrPAR[[i]], 0, 0))\n    prR <- prF <- c()\n    for (j in 1:nrow(x$mlrPAR[[i]])){\n\n      prR <- rbind(prR, exp(x$mlrPAR[[i]][j, ] %*% t(sqR)))\n      prF <- rbind(prF, exp(x$mlrPAR[[i]][j, ] %*% t(sqF)))\n    }\n\n    prR <- as.data.frame(t(prR)); prF <- as.data.frame(t(prF))\n    colnames(prR) <- colnames(prF) <- rownames(x$mlrPAR[[i]])\n    prR$sum <- apply(prR, 1, sum) + 1; prF$sum <- apply(prF, 1, sum) + 1\n\n    for (j in 1:nrow(x$mlrPAR[[i]])){\n      prR <- data.frame(prR, prR[, j]/prR[, \"sum\"])\n      prF <- data.frame(prF, prF[, j]/prF[, \"sum\"])\n    }\n\n    hvR <- data.frame(1 - apply(prR[, (nrow(x$mlrPAR[[i]])+2):ncol(prR)], 1, sum),\n                      prR[, (nrow(x$mlrPAR[[i]])+2):ncol(prR)], \"R\")\n    hvF <- data.frame(1 - apply(prF[, (nrow(x$mlrPAR[[i]])+2):ncol(prF)], 1, sum),\n                      prF[, (nrow(x$mlrPAR[[i]])+2):ncol(prF)], \"F\")\n    hvR <- data.frame(hvR, score = sq)\n    hvF <- data.frame(hvF, score = sq)\n    colnames(hvR) <- colnames(hvF) <- c(x$key[i], rownames(x$mlrPAR[[i]]), \"group\", \"score\")\n    hv <- rbind(hvR, hvF)\n\n    df <- melt(hv, id = c(\"score\", \"group\"))\n    df$group <- as.factor(df$group)\n\n    df2 <- rbind(data.frame(prop.table(table(x$Data[x$group == 1, i], score[x$group == 1]), 2),\n                            table(x$Data[x$group == 1, i], score[x$group == 1]),\n                            group = \"1\"),\n                 data.frame(prop.table(table(x$Data[x$group == 0, i], score[x$group == 0]), 2),\n                            table(x$Data[x$group == 0, i], score[x$group == 0]),\n                            group = \"0\"))\n\n    df2$score <- as.numeric(levels(df2$Var2))[df2$Var2]\n    df2$answ <- relevel(df2$Var1, ref = paste(x$key[i]))\n    df2$group <- as.factor(df2$group)\n\n    plot_CC[[i]] <-  ggplot() +\n      geom_line(data = df,\n                aes_string(x = \"score\" , y = \"value\",\n                    colour = \"variable\", linetype = \"group\")) +\n      geom_point(data = df2,\n                 aes_string(x = \"score\", y = \"Freq\",\n                     colour = \"answ\", fill = \"answ\",\n                     size = \"Freq.1\"),\n                 alpha = 0.5, shape = 21) +\n\n      ylim(0, 1) +\n      labs(title = paste(\"Item\", i),\n           x = \"Standardized Total Score\",\n           y = \"Probability of Correct Answer\") +\n      scale_linetype_discrete(name = \"Group\", labels = c(\"Reference\", \"Focal\")) +\n      scale_size_continuous(name = \"Counts\")  +\n      scale_colour_discrete(name = \"Answer\", breaks = df2$answ) +\n      scale_fill_discrete(guide = F) +\n\n      theme_bw() +\n      theme(axis.line  = element_line(colour = \"black\"),\n            text = element_text(size = 14),\n            panel.grid.major = element_blank(),\n            panel.grid.minor = element_blank(),\n            panel.background = element_blank(),\n            legend.position = c(0, 1),\n            legend.justification = c(0, 1),\n            legend.background = element_blank(),\n            legend.box = \"horizontal\",\n            legend.key = element_rect(colour = \"white\"),\n            plot.title = element_text(face = \"bold\"),\n            legend.key.width = unit(1, \"cm\"))\n\n  }\n\n  return(plot_CC)\n}\n",
    "created" : 1482141517980.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3261725235",
    "id" : "78F6BB7D",
    "lastKnownWriteTime" : 1482398234,
    "last_content_update" : -2147483648,
    "path" : "U:/difNLR/R/ddfMLR.R",
    "project_path" : "R/ddfMLR.R",
    "properties" : {
        "tempName" : "Untitled7"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}