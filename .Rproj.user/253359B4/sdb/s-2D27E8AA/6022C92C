{
    "collab_server" : "",
    "contents" : "#' DDF likelihood ratio statistics based on Multinomial Log-linear Regression model.\n#'\n#' @aliases MLR\n#'\n#' @description Calculates DDF likelihood ratio statistics based on multinomial log-linear model.\n#'\n#' @param Data character: the unscored data matrix only.\n#' @param group numeric or character: the binary vector of group membership\n#' @param key character: the answer key.\n#' @param type character: type of DIF to be tested (either \"both\" (default), \"udif\", or \"nudif\").\n#' See \\strong{Details}.\n#' @param p.adjust.method character: method for multiple comparison correction.\n#' See \\strong{Details}.\n#' @param alpha numeric: significance level (default is 0.05).\n#'\n#' @usage MLR(Data, group, key, type = \"both\", p.adjust.method = \"none\", alpha = 0.05)\n#' @details\n#' Calculates DDF likelihood ratio statistics based on multinomial log-linear model.\n#'\n#' The \\code{Data} is a matrix whose rows represents examinee unscored answers and\n#' columns correspond to the items. The \\code{group} must be a vector of the same\n#' length as \\code{nrow(data)}. The \\code{key} must be a vector of correct answers\n#' corresponding to columns of \\code{Data}.\n#'\n#' The \\code{type} corresponds to type of DIF to be tested. Possible values are \\code{\"both\"}\n#' to detect any DIF (uniform and/or non-uniform), \\code{\"udif\"} to detect only uniform DIF or\n#' \\code{\"nudif\"} to detect only non-uniform DIF.\n#'\n#' The \\code{p.adjust.method} is a character for \\code{p.adjust} function from the\n#' \\code{stats} package. Possible values are \\code{\"holm\"}, \\code{\"hochberg\"},\n#' \\code{\"hommel\"}, \\code{\"bonferroni\"}, \\code{\"BH\"}, \\code{\"BY\"}, \\code{\"fdr\"}, \\code{\"none\"}.\n#'\n#' Missing values are allowed but discarded for item estimation. They must be coded as \\code{NA}\n#' for both, \\code{data} and \\code{group} parameters.\n#'\n#' @return A list with the following arguments:\n#' \\describe{\n#'   \\item{\\code{Sval}}{the values of likelihood ratio test statistics.}\n#'   \\item{\\code{pval}}{the p-values by likelihood ratio test.}\n#'   \\item{\\code{adj.pval}}{the adjusted p-values by likelihood ratio test using \\code{p.adjust.method}.}\n#'   \\item{\\code{df}}{the degress of freedom of likelihood ratio test.}\n#'   \\item{\\code{par.m0}}{the estimates of null model.}\n#'   \\item{\\code{par.m1}}{the estimates of alternative model.}\n#'   \\item{\\code{cov.m0}}{the estimates of covariance structure of null model.}\n#'   \\item{\\code{cov.m1}}{the estimates of covariance structure of alternative model.}\n#'   }\n#'\n#' @author\n#' Adela Drabinova \\cr\n#' Institute of Computer Science, The Czech Academy of Sciences \\cr\n#' Faculty of Mathematics and Physics, Charles University \\cr\n#' adela.drabinova@gmail.com \\cr\n#'\n#' Patricia Martinkova \\cr\n#' Institute of Computer Science, The Czech Academy of Sciences \\cr\n#' martinkova@cs.cas.cz \\cr\n#'\n#'\n#' @seealso \\code{\\link[stats]{p.adjust}}\n#'\n#' @examples\n#' \\dontrun{\n#' # loading data based on GMAT\n#' data(GMATtest, GMATkey)\n#'\n#' Data  <- GMATtest[, colnames(GMATtest) != \"group\"]\n#' group <- GMATtest[, \"group\"]\n#' key <- GMATkey\n#'\n#' # Testing both DIF effects\n#' MLR(Data, group, key, type = \"both\")\n#'\n#' # Testing uniform DIF effects\n#' MLR(Data, group, key, type = \"udif\")\n#'\n#' # Testing non-uniform DIF effects\n#' MLR(Data, group, key, type = \"nudif\")\n#' }\n#' @keywords DDF\n#' @export\n#' @importFrom stats coef vcov p.adjust.methods anova\n#' @importFrom nnet multinom\n#' @importFrom CTT score\n\n\nMLR <- function(Data, group, key, type = \"both\", p.adjust.method = \"none\", alpha = 0.05){\n\n  x <- scale(unlist(score(Data, key)))\n  m <- ncol(Data)\n  n <- nrow(Data)\n\n  m0 <- lapply(1:m, function(i) switch(type,\n                                       \"both\" = multinom(relevel(as.factor(Data[, i]),\n                                                                 ref = paste(key[i])) ~ x * group,\n                                                         trace = F),\n                                       \"nudif\" = multinom(relevel(as.factor(Data[, i]),\n                                                                  ref = paste(key[i])) ~ x * group,\n                                                          trace = F),\n                                       \"udif\" = multinom(relevel(as.factor(Data[, i]),\n                                                                 ref = paste(key[i])) ~ x + group,\n                                                         trace = F)))\n  m1 <- lapply(1:m, function(i) switch(type,\n                                       \"both\" = multinom(relevel(as.factor(Data[, i]),\n                                                                 ref = paste(key[i])) ~ x,\n                                                         trace = F),\n                                       \"nudif\" = multinom(relevel(as.factor(Data[, i]),\n                                                                  ref = paste(key[i])) ~ x + group,\n                                                          trace = F),\n                                       \"udif\" = multinom(relevel(as.factor(Data[, i]),\n                                                                 ref = paste(key[i])) ~ x,\n                                                         trace = F)))\n\n  MLRtest <- lapply(1:m, function(i) anova(m0[[i]], m1[[i]]))\n  MLRstat <- sapply(1:m, function(i) c(MLRtest[[i]]$`LR stat.`[2], MLRtest[[i]]$`Pr(Chi)`[2]))\n  df <- lapply(1:m, function(i) MLRtest[[i]]$`Resid. df`)\n\n  adjusted.pval <- p.adjust(MLRstat[2, ], method = p.adjust.methods)\n\n  par.m1 <- lapply(m1, coef)\n  par.m0 <- lapply(m0, coef)\n\n  cov.m1 <- lapply(m1, vcov)\n  cov.m0 <- lapply(m0, vcov)\n\n  # se.m1 <- sqrt(t(sapply(cov.m1, diag)))\n  # se.m0 <- sqrt(t(sapply(cov.m0, diag)))\n\n  # rownames(par.m1) <- rownames(par.m0) <- rownames(se.m1) <- rownames(se.m0) <- paste(\"Item\", 1:m, sep = \"\")\n  results <- list(Sval = MLRstat[1, ],\n                  pval = MLRstat[2, ], adjusted.pval = adjusted.pval,\n                  df = df,\n                  par.m0 = par.m0, cov.m0 = cov.m0,\n                  par.m1 = par.m1, cov.m1 = cov.m1)\n  return(results)\n}\n\n\n\n",
    "created" : 1482141887507.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1551590537",
    "id" : "6022C92C",
    "lastKnownWriteTime" : 1482225686,
    "last_content_update" : -2147483648,
    "path" : "U:/difNLR/R/MLR.R",
    "project_path" : "R/MLR.R",
    "properties" : {
        "tempName" : "Untitled7"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}