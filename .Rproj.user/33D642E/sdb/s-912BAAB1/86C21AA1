{
    "collab_server" : "",
    "contents" : "#' Non-Linear Regression DIF statistic\n#'\n#' @aliases NLR\n#'\n#' @description Performs DIF detection procedure based on Non-Linear Regression and either F-test or likelihood ratio test of submodel.\n#'\n#' @param Data numeric: either binary data matrix only, or the binary data matrix plus the vector of group .\n#' See \\strong{Details}.\n#' @param group numeric: binary vector of group membership. \"0\" for reference group, \"1\" for focal group.\n#' @param model character: generalized logistic regression model to be fitted. See \\strong{Details}.\n#' @param type character: type of DIF to be tested (either \"both\" (default), \"udif\", or \"nudif\").\n#' See \\strong{Details}.\n#' @param p.adjust.method character: method for multiple comparison correction. See \\strong{Details}.\n#' @param start numeric: matrix with n rows (where n is the number of items) and 8 columns containing initial\n#' item parameters estimates. See \\strong{Details}.\n#' @param test character: test to be performed for DIF detection (either \"LR\" (default), or \"F\").\n#' See \\strong{Details}.\n#' @param alpha numeric: significance level (default is 0.05).\n#'\n#' @usage NLR(Data, group, model, type = \"both\", start,\n#' p.adjust.method = \"none\", test = \"LR\", alpha = 0.05)\n#'\n#' @details\n#' DIF detection procedure based on Non-Linear Regression is the extension\n#' of Logistic Regression procedure (Swaminathan and Rogers, 1990).\n#'\n#' The \\code{Data} is a matrix whose rows represents examinee scored answers\n#' (\"1\" correct, \"0\" incorrect) and columns correspond to the items.\n#' The \\code{group} must be a vector of the same length as \\code{nrow(data)}.\n#'\n#' The options of \\code{model} are as follows: \\code{Rasch} for one-parameter logistic model with\n#' discrimination parameter fixed on value 1 for both groups, \\code{1PL} for one-parameter logistic\n#' model with discrimination parameter fixed for both groups, \\code{2PL} for logistic regression model,\n#' \\code{3PLcg} for three-parameter logistic regression model with fixed guessing for both groups,\n#' \\code{3PLdg} for three-parameter logistic regression model with fixed inattention for both groups, or\n#' \\code{4PLcgdg} for four-parameter logistic regression model with fixed guessing and inattention\n#' parameter for both groups.\n\n#' The \\code{type} corresponds to type of DIF to be tested. Possible values\n#' are \\code{\"both\"} to detect any DIF (uniform and/or non-uniform), \\code{\"udif\"}\n#' to detect only uniform DIF or \\code{\"nudif\"} to detect only non-uniform DIF.\n#'\n#' The \\code{start} is a matrix with a number of rows equal to number of items and with 8 columns.\n#' First 4 columns represent parameters (a, b, c, d) of generalized logistic regression model\n#' for reference group. Last 4 columns represent differences of parameters (aDif, bDif, cDif, dDif)\n#' of generalized logistic regression model between reference and focal group.  If not specified, starting\n#' values are calculated with \\code{startNLR} function.\n#'\n#' The \\code{p.adjust.method} is a character for \\code{p.adjust} function from the\n#' \\code{stats} package. Possible values are \\code{\"holm\"}, \\code{\"hochberg\"},\n#' \\code{\"hommel\"}, \\code{\"bonferroni\"}, \\code{\"BH\"}, \\code{\"BY\"}, \\code{\"fdr\"},\n#' \\code{\"none\"}.\n#'\n#' Missing values are allowed but discarded for item estimation. They must be coded\n#' as \\code{NA} for both, \\code{data} and \\code{group} parameters.\n#'\n# ' @return A list of class 'difNLR' with the following arguments:\n# ' \\describe{\n# '   \\item{\\code{DIF}}{either the column indicators of the items which were detected as DIF, or \\code{\"NONE\"}.}\n# '   \\item{\\code{test}}{the test used for DIF detection.}\n# '   \\item{\\code{Sval}}{the values of \\code{test} statistics.}\n# '   \\item{\\code{pval}}{the p-values by \\code{test}.}\n# '   \\item{\\code{df}}{the degress of freedom of \\code{test}.}\n# '   \\item{\\code{coef}}{the matrix of estimated item parameters.}\n# '   \\item{\\code{vcov}}{the list of estimated covariance matrices of item parameters.}\n# '   \\item{\\code{group}}{the vector of group membership.}\n# '   \\item{\\code{data}}{the binary data matrix.}\n# '   \\item{\\code{type}}{character: type of DIF that was tested.}\n# '   \\item{\\code{alpha}}{numeric: significance level.}\n# '   \\item{\\code{conv.fail}}{numeric: number of convergence issues.}\n# '   \\item{\\code{conv.fail.which}}{the indicators of the items which did not converge.}\n# '   \\item{\\code{p.adjust.method}}{character: method for multiple comparison correction which was applied.}\n# ' }\n#'\n#' @author\n#' Adela Drabinova \\cr\n#' Institute of Computer Science, The Czech Academy of Sciences \\cr\n#' Faculty of Mathematics and Physics, Charles University \\cr\n#' adela.drabinova@gmail.com \\cr\n#'\n#' Patricia Martinkova \\cr\n#' Institute of Computer Science, The Czech Academy of Sciences \\cr\n#' martinkova@cs.cas.cz \\cr\n#'\n#' Karel Zvara \\cr\n#' Faculty of Mathematics and Physics, Charles University \\cr\n#'\n#' @references\n#' Drabinova, A. and Martinkova P. (2016). Detection of Differenctial Item Functioning Based on Non-Linear Regression, Technical Report, V-1229, \\url{http://hdl.handle.net/11104/0259498}.\n#'\n#' Swaminathan, H. and Rogers, H. J. (1990). Detecting Differential Item Functioning Using Logistic Regression Procedures. Journal of Educational Measurement, 27, 361-370.\n#'\n#' @seealso \\code{\\link[stats]{p.adjust}}\n#'\n#' @examples\n#' \\dontrun{\n#' # loading data based on GMAT\n#' data(GMAT)\n#'\n#' data  <- GMAT[, colnames(GMAT) != \"group\"]\n#' group <- GMAT[, \"group\"]\n#'\n#' # Testing both DIF effects using LR test (default)\n#' # and model with fixed guessing for both groups\n#' NLR(Data, group, model = \"3PLcg\")\n#'\n#' # using F test\n#' NLR(Data, group, model = \"3PLcg\", test = \"F\")\n#'\n#' # Testing both DIF effects with Benjamini-Hochberg correction\n#' NLR(Data, group, model = \"3PLcg\", p.adjust.method = \"BH\")\n#'\n#' # Testing uniform DIF effects\n#' NLR(Data, group, model = \"3PLcg\", type = \"udif\")\n#' # Testing non-uniform DIF effects\n#' NLR(Data, group, model = \"3PLcg\", type = \"nudif\")\n#' }\n#' @keywords DIF\n#' @export\n\n\n\nNLR <- function(Data, group, model, type = \"both\", start,\n                p.adjust.method = \"none\", test = \"LR\", alpha = 0.05){\n\n  gNLR <- function(x, g, a, b, c, d, aDif, bDif, cDif, dDif){\n    return((c + cDif * g) + ((d + dDif * g) - (c + cDif * g)) / (1 + exp(-(a + aDif * g) * (x - (b + bDif * g)))))\n  }\n\n  if(missing(start)){\n    start <- startNLR(Data, group, model)\n  }\n  start_m0 <- start_m1 <- start\n  start_m1[, \"aDif\"] <- 0\n  if (!(type == \"nudif\")){\n    start_m1[, \"bDif\"] <- 0\n    if (type == \"udif\"){\n      start_m0[, \"aDif\"] <- 0\n    }\n  }\n\n  constr <- constrNLR(model = model, type = type)\n  lowerM0 <- constr[\"lowerM0\", ]; upperM0 <- constr[\"upperM0\", ]\n  lowerM1 <- constr[\"lowerM1\", ]; upperM1 <- constr[\"upperM1\", ]\n\n  fixedM0 <- lowerM0[lowerM0 == upperM0]\n  fixedM1 <- lowerM1[lowerM1 == upperM1]\n\n  x <- scale(apply(Data, 1, sum))\n  m <- ncol(Data)\n  n <- nrow(Data)\n\n  if (length(fixedM0) == 0){\n    whM0 <- colnames(start_m0)\n  } else {\n    for (i in 1:length(fixedM0)){\n      assign(names(fixedM0)[i], fixedM0[i])\n    }\n    whM0 <- colnames(start_m0)[(!(colnames(start_m0) %in% names(fixedM0)))]\n    start_m0 <- structure(data.frame(start_m0[, whM0]), .Names = whM0)\n    lowerM0 <- lowerM0[whM0]; upperM0 <- upperM0[whM0]\n  }\n\n  m0 <- lapply(1:m, function(i) tryCatch(nls(Data[, i] ~ gNLR(x, group, a, b, c, d, aDif, bDif, cDif, dDif),\n                                             algorithm = \"port\",\n                                             start = structure(start_m0[i, ], .Names = whM0),\n                                             lower = lowerM0,\n                                             upper = upperM0),\n                                         error = function(e){cat(\"ERROR : \",\n                                                                 conditionMessage(e), \"\\n\")}))\n\n  if (length(fixedM0) != 0){\n    for (i in 1:length(fixedM0)){\n      rm(list = as.character(names(fixedM0)[i]))\n    }\n  }\n\n  whM1 <- colnames(start_m1)[(!(colnames(start_m1) %in% names(fixedM1)))]\n  start_m1 <- structure(data.frame(start_m1[, whM1]), .Names = whM1)\n\n  lowerM1 <- lowerM0[whM1]; upperM1 <- upperM0[whM1]\n\n  for (i in 1:length(fixedM1)){\n    assign(names(fixedM1)[i], fixedM1[i])\n  }\n\n  m1 <- lapply(1:m, function(i) tryCatch(nls(Data[, i] ~ gNLR(x, group, a, b, c, d, aDif, bDif, cDif, dDif),\n                                             algorithm = \"port\",\n                                             start = structure(start_m1[i, ], .Names = whM1),\n                                             lower = lowerM1,\n                                             upper = upperM1),\n                                         error = function(e){cat(\"ERROR : \",\n                                                                 conditionMessage(e), \"\\n\")}))\n\n  cfM0 <- unlist(lapply(m0, is.null)); cfM1 <- unlist(lapply(m1, is.null))\n  conv.fail <- sum(cfM0, cfM1)\n  conv.fail.which <- which(cfM0 | cfM1)\n\n  if (conv.fail > 0) {\n    warning(\"Convergence failure\")\n  }\n\n  if (test == \"F\"){\n    pval <- Fval <- rep(NA, m)\n    df <- switch(type,\n                 both = c(2, n - 5),\n                 udif = c(1, n - 4),\n                 nudif = c(1, n - 5))\n    Fval[which(!(cfM1 | cfM0))] <- sapply(which(!(cfM1 |  cfM0)),\n                                                        function(l) ((m1[[l]]$m$deviance() - m0[[l]]$m$deviance())/df[1])/(m0[[l]]$m$deviance()/df[2]))\n    pval[which(!(cfM1 | cfM0))] <- sapply(which(!(cfM1 | cfM0)),\n                                                        function(l) (1 - pf(Fval[l], df[1], df[2])))\n  } else {\n    pval <- LRval <- rep(NA, m)\n    df <- switch(type,\n                 both = 2,\n                 udif = 1,\n                 nudif = 1)\n    LRval[which(!(cfM1 | cfM0))] <- sapply(which(!(cfM1 |  cfM0)),\n                                                         function(l) -2 * c(logLik(m1[[l]]) - logLik(m0[[l]])))\n    pval[which(!(cfM1 | cfM0))] <- sapply(which(!(cfM1 | cfM0)),\n                                                        function(l) (1 - pchisq(LRval[l], df)))\n  }\n\n  adjusted.pval <- p.adjust(pval, method = p.adjust.method)\n\n  par.m1 <- se.m1 <- structure(data.frame(matrix(NA, nrow = m, ncol = length(lowerM1))), .Names = names(lowerM1))\n  par.m0 <- se.m0 <- structure(data.frame(matrix(NA, nrow = m, ncol = length(lowerM0))), .Names = names(lowerM0))\n\n  if (dim(par.m1)[2] == 1){\n    par.m1[which(!cfM1), ] <- sapply(m1[which(!cfM1)], coef)\n    par.m1 <- structure(data.frame(par.m1), names = unique(names(par.m1)))\n  } else {\n    par.m1[which(!cfM1), ] <- t(sapply(m1[which(!cfM1)], coef))\n  }\n  par.m0[which(!cfM0), ] <- t(sapply(m0[which(!cfM0)], coef))\n\n  cov.m0 <- cov.m1 <- lapply(1:m, function(i) NA)\n  cov.m1[which(!cfM1)] <- lapply(m1[which(!cfM1)], vcov)\n  cov.m0[which(!cfM0)] <- lapply(m0[which(!cfM0)], vcov)\n\n  if (dim(par.m1)[2] == 1){\n    se.m1[which(!cfM1), ] <- sqrt(sapply(cov.m1[which(!cfM1)], diag))\n    se.m1 <- structure(data.frame(se.m1), names = unique(names(se.m1)))\n  } else {\n    se.m1[which(!cfM1), ] <- sqrt(t(sapply(cov.m1[which(!cfM1)], diag)))\n  }\n  se.m0[which(!cfM0), ] <- sqrt(t(sapply(cov.m0[which(!cfM0)] , diag)))\n\n  rownames(par.m1) <- rownames(par.m0) <- rownames(se.m1) <- rownames(se.m0) <- paste(\"Item\", 1:m, sep = \"\")\n  results <- list(Sval = switch(test, \"F\" = Fval, \"LR\" = LRval),\n                  pval = pval, adjusted.pval = adjusted.pval,\n                  df = df, test = test,\n                  par.m0 = par.m0, se.m0 = se.m0, cov.m0 = cov.m0,\n                  par.m1 = par.m1, se.m1 = se.m1, cov.m1 = cov.m1,\n                  conv.fail = conv.fail, conv.fail.which = conv.fail.which)\n  return(results)\n}\n",
    "created" : 1484044603408.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4137454592",
    "id" : "86C21AA1",
    "lastKnownWriteTime" : 1484043169,
    "last_content_update" : 1484043169,
    "path" : "~/GitHub/difNLR/R/NLR.R",
    "project_path" : "R/NLR.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}