{
    "collab_server" : "",
    "contents" : "#' Performs DIF detection using Non-Linear Regression method.\n#'\n#' @aliases difNLR print.difNLR plot.difNLR fitted.difNLR predict.difNLR\n#'\n#' @description Performs DIF detection procedure based on Non-Linear Regression and either F-test or likelihood ratio test of submodel.\n#' @param data numeric: binary data matrix. See \\strong{Details}.\n#' @param group numeric: binary vector of group membership. \"0\" for reference group, \"1\" for focal group.\n#' @param type character: type of DIF to be tested (either \"both\" (default), \"udif\", or \"nudif\"). See \\strong{Details}.\n#' @param p.adjust.method character: method for multiple comparison correction. See \\strong{Details}.\n#' @param start numeric: matrix with n rows (where n is the number of items) and at most 5 columns containing initial item parameters estimates. See \\strong{Details}.\n#' @param test character: test to be performed for DIF detection (either \"F\" (default), or \"LR\"). See \\strong{Details}.\n#' @param alpha numeric: significance level (default is 0.05).\n#' @param x an object of 'difNLR' class\n#' @param object an object of 'difNLR' class\n#' @param plot.type character: type of plot to be plotted (either \"cc\" for characteristic curve (default), or \"stat\" for test statistics). See \\strong{Details}.\n#' @param item either character (\"all\"), or numeric vector, or single number corresponding to column indicators. See \\strong{Details}.\n#' @param col character: single value, or vector of two values representing colors for plot.\n#' @param shape integer: shape parameter for plot.\n#' @param size numeric: single number, or vector of two numbers representing line width in plot.\n#' @param linetype numeric: single number, or vector of two numbers representing line type in plot for reference and focal group.\n#' @param title string: title of plot.\n#' @param score numeric: standardized total score of subject.\n#' @param ... other generic parameters for \\code{plot}, \\code{fitted} or \\code{predict} functions.\n#'\n#' @usage difNLR(data, group,  type = \"both\", p.adjust.method = \"BH\",\n#'   start, test = \"F\", alpha = 0.05)\n#'\n#' @details\n#' DIF detection procedure based on Non-Linear Regression is the extension of Logistic Regression procedure (Swaminathan and Rogers, 1990).\n#'\n#' The \\code{data} is a matrix whose rows represents examinee answers (\"1\" correct, \"0\" incorrect) and columns correspond to the items. The \\code{group} must be a vector of the same length as \\code{nrow(data)}.\n#'\n#' The \\code{type} corresponds to type of DIF to be tested. Possible values are \\code{\"both\"} to detect any DIF (uniform and/or non-uniform), \\code{\"udif\"} to detect only uniform DIF or \\code{\"nudif\"} to detect only non-uniform DIF.\n#'\n#' The \\code{start} is a matrix with a number of rows equal to number of items. The number of columns correspond to number of parameters in model in alternative hypothesis (5 for values \\code{\"both\"} and \\code{\"nudif\"} in type, 4 for \\code{\"udif\"} in type). If start missing, initial values are calculated by \\code{startNLR} function.\n#'\n#' The \\code{p.adjust.method} is a character for \\code{p.adjust} function from the \\code{stats} package. Possible values are \\code{\"holm\"}, \\code{\"hochberg\"}, \\code{\"hommel\"}, \\code{\"bonferroni\"}, \\code{\"BH\"}, \\code{\"BY\"}, \\code{\"fdr\"}, \\code{\"none\"}.\n#'\n#' The output of the difNLR is displayed by the \\code{print.difNLR} function.\n#'\n#' Two types of plots are available. The first one is obtained by setting \\code{plot.type = \"cc\"} (default). The characteristic curve for item specified in item option is plotted. For default option \\code{\"all\"} of item, characteristic curves of all converged items are plotted. The drawn curves represent best model.\n#' The second plot is obtained by setting \\code{plot.type = \"stat\"}. The  test statistics (either F-test, or LR-test, depends on argument \\code{test}) are displayed on the Y axis, for each coverged item. The detection threshold is displayed by a horizontal line and items detected as DIF are printed with the red color. Only parameters \\code{size} and \\code{title} are used.\n#'\n#' Fitted values are extracted by the \\code{fitted.difNLR} function for item(s) specified in \\code{item} argument.\n#'\n#' Predicted values are produced by the \\code{predict.difNLR} function for item(s) specified in \\code{item} argument. \\code{score} represents standardized total score of new subject and \\code{group} argument represents group membership of new subject.\n#'\n#' Missing values are allowed but discarded for item estimation. They must be coded as \\code{NA} for both, \\code{data} and \\code{group} parameters.\n#'\n#' @return A list of class 'difNLR' with the following arguments:\n#' \\describe{\n#'   \\item{\\code{DIF}}{either the column indicators of the items which were detected as DIF, or \\code{\"NONE\"}.}\n#'   \\item{\\code{test}}{the test used for DIF detection.}\n#'   \\item{\\code{Sval}}{the values of \\code{test} statistics.}\n#'   \\item{\\code{pval}}{the p-values by \\code{test}.}\n#'   \\item{\\code{df}}{the degress of freedom of \\code{test}.}\n#'   \\item{\\code{coef}}{the matrix of estimated item parameters.}\n#'   \\item{\\code{vcov}}{the list of estimated covariance matrices of item parameters.}\n#'   \\item{\\code{group}}{the vector of group membership.}\n#'   \\item{\\code{data}}{the binary data matrix.}\n#'   \\item{\\code{type}}{character: type of DIF that was tested.}\n#'   \\item{\\code{alpha}}{numeric: significance level.}\n#'   \\item{\\code{conv.fail}}{numeric: number of convergence issues.}\n#'   \\item{\\code{conv.fail.which}}{the indicators of the items which did not converge.}\n#'   \\item{\\code{p.adjust.method}}{character: method for multiple comparison correction which was applied.}\n#' }\n#'\n#' @author\n#' Adela Drabinova \\cr\n#' Institute of Computer Science, The Czech Academy of Sciences \\cr\n#' Faculty of Mathematics and Physics, Charles University \\cr\n#' adela.drabinova@gmail.com \\cr\n#'\n#' Patricia Martinkova \\cr\n#' Institute of Computer Science, The Czech Academy of Sciences \\cr\n#' martinkova@cs.cas.cz \\cr\n#'\n#' Karel Zvara \\cr\n#' Faculty of Mathematics and Physics, Charles University \\cr\n#'\n#' @references\n#' Drabinova, A. and Martinkova P. (2016). Detection of Differenctial Item Functioning Based on Non-Linear Regression, Technical Report, V-1229, \\url{http://hdl.handle.net/11104/0259498}.\n#'\n#' Swaminathan, H. and Rogers, H. J. (1990). Detecting Differential Item Functioning Using Logistic Regression Procedures. Journal of Educational Measurement, 27, 361-370.\n#'\n#' @seealso \\code{\\link[stats]{p.adjust}}\n#'\n#' @examples\n#' \\dontrun{\n#' # loading data based on GMAT\n#' data(GMAT)\n#'\n#' data  <- GMAT[, colnames(GMAT) != \"group\"]\n#' group <- GMAT[, \"group\"]\n#' # Testing both DIF effects using F test and Benjamini-Hochberg correction (default)\n#' x <- difNLR(data, group)\n#'\n#' # Testing both DIF effects using likelihood-ratio test\n#' x <- difNLR(data, group, test = \"LR\")\n#'\n#' # Testing both DIF effects with none multiple comparison correction\n#' difNLR(data, group, type = \"both\", p.adjust.method = \"none\")\n#'\n#' # Testing uniform DIF effects\n#' difNLR(data, group, type = \"udif\")\n#' # Testing non-uniform DIF effects\n#' difNLR(data, group, type = \"nudif\")\n#'\n#' # Graphical devices\n#' plot(x)\n#' plot(x, item = x$DIF)\n#' plot(x, plot.type = \"stat\")\n#'\n#' # Fitted values\n#' fitted(x)\n#' fitted(x, item = 1)\n#' # Predicted values\n#' predict(x)\n#' predict(x, item = 1)\n#'\n#' # Predicted values for new subjects\n#' predict(x, item = 1, score = 0, group = 1)\n#' predict(x, item = 1, score = 0, group = 0)\n#' }\n#' @keywords DIF\n#' @export\n\n\ndifNLR <- function(data, group, type = \"both\", p.adjust.method = \"BH\", start,\n                    test = \"F\", alpha = 0.05)\n{\n  if (length(levels(as.factor(group))) != 2)\n    stop(\"'group' must be binary vector\", call. = FALSE)\n  if (length(levels(as.factor(group))) != 2)\n    stop(\"'group' must be binary vector\", call. = FALSE)\n  if (is.matrix(data) | is.data.frame(data)) {\n    if (!all(apply(data, 2, function(i) {\n      length(levels(as.factor(i))) == 2\n    })))\n      stop(\"'data' must be data frame or matrix of binary vectors\",\n           call. = FALSE)\n    if (nrow(data) != length(group))\n      stop(\"'data' must have the same number of rows as is length of vector 'group'\",\n           call. = FALSE)\n  }\n  else {\n    stop(\"'data' must be data frame or matrix of binary vectors\",\n         call. = FALSE)\n  }\n  if (!type %in% c(\"udif\", \"nudif\", \"both\") | !is.character(type))\n    stop(\"'type' must be either 'udif', 'nudif' or 'both'\",\n         call. = FALSE)\n  if (!test %in% c(\"F\", \"LR\") | !is.character(type))\n    stop(\"'test' must be either 'F' or 'LR'\",\n         call. = FALSE)\n  if (alpha > 1 | alpha < 0)\n    stop(\"'alpha' must be between 0 and 1\",\n         call. = FALSE)\n  if (missing(start)) {\n    start <- startNLR(data, group)\n    start_m0 <- switch(type,\n                       both = start,\n                       nudif = start,\n                       udif = start[, -4])\n    start_m1 <- switch(type,\n                       both = start[, -c(4, 5)],\n                       nudif = start[, -4],\n                       udif = start[, -c(4, 5)])\n  }\n  else {\n    if (ncol(start) != 5 & type != \"udif\")\n      stop(\"'start' must be data frame or matrix with 5 columns\",\n           call. = FALSE)\n    if (ncol(start) != 4 & type == \"udif\")\n      stop(\"'start' must be data frame or matrix with 4 columns for detecting uniform DIF\",\n           call. = FALSE)\n    if (nrow(start) != ncol(data))\n      stop(\"'start' must be data frame or matrix with starting values for each item\",\n           call. = FALSE)\n    start_m0 <- start\n    start_m1 <- switch(type,\n                       both = start[, -c(4, 5)],\n                       nudif = start[, -4],\n                       udif = start[, -4])\n  }\n\n  # NA values\n  DATA <- data.frame(data, group)\n  DATA <- na.omit(DATA)\n  data <- DATA[, !(names(DATA) %in% \"group\")]\n  group <- DATA$group\n\n  regFce_nonUDIF <- deriv3( ~ c + (1 - c) / (1 + exp(-(a + aDif * group) * (x - (b + bDif * group)))),\n                            namevec = c(\"a\", \"b\", \"c\", \"aDif\", \"bDif\"),\n                            function.arg = function(x, group, a, b, c, aDif, bDif){})\n  regFce_UDIF    <- deriv3( ~ c + (1 - c) / (1 + exp(-a * (x - (b + bDif * group)))),\n                            namevec = c(\"a\", \"b\", \"c\", \"bDif\"),\n                            function.arg = function(x, group, a, b, c, bDif){})\n  regFce_noDIF   <- deriv3( ~ c + (1 - c) / (1 + exp(-a * (x - b))),\n                            namevec = c(\"a\", \"b\", \"c\"),\n                            function.arg = function(x, group, a, b, c){})\n\n  stand_total_score <- c(scale(apply(data, 1, sum)))\n  m <- ncol(data)\n  n <- nrow(data)\n  conv.fail <- 0\n  k <- Inf\n  estim_m0 <- lapply(1:m, function(i) NA)\n  hv <- which(!(sapply(1:m, function(i) is(try(switch(type,\n                                                      both = nls(data[, i] ~ regFce_nonUDIF(stand_total_score, group, a, b, c, aDif, bDif),\n                                                                 algorithm = \"port\",\n                                                                 start = start_m0[i, ],\n                                                                 lower = c(-k, -k, 0, -k, -k),\n                                                                 upper = c(k, k, 1, k, k)),\n                                                      nudif = nls(data[, i] ~ regFce_nonUDIF(stand_total_score, group, a, b, c, aDif, bDif),\n                                                                  algorithm = \"port\",\n                                                                  start = start_m0[i, ],\n                                                                  lower = c(-k, -k, 0, -k, -k),\n                                                                  upper = c(k, k, 1, k, k)),\n                                                      udif = nls(data[, i] ~ regFce_UDIF(stand_total_score, group, a, b, c, bDif),\n                                                                 algorithm = \"port\",\n                                                                 start = start_m0[i, ],\n                                                                 lower = c(-k, -k, 0, -k),\n                                                                 upper = c(k, k, 1, k))),\n                                               silent = T), \"try-error\"))))\n  estim_m0[hv] <- lapply(hv, function(i) switch(type,\n                                                both = nls(data[, i] ~ regFce_nonUDIF(stand_total_score, group, a, b, c, aDif, bDif),\n                                                           algorithm = \"port\",\n                                                           start = start_m0[i, ],\n                                                           lower = c(-k, -k, 0, -k, -k),\n                                                           upper = c(k, k, 1, k, k)),\n                                                nudif = nls(data[, i] ~ regFce_nonUDIF(stand_total_score, group, a, b, c, aDif, bDif),\n                                                            algorithm = \"port\",\n                                                            start = start_m0[i, ],\n                                                            lower = c(-k, -k, 0, -k, -k),\n                                                            upper = c(k, k, 1, k, k)),\n                                                udif = nls(data[, i] ~ regFce_UDIF(stand_total_score, group, a, b, c, bDif),\n                                                           algorithm = \"port\",\n                                                           start = start_m0[i, ],\n                                                           lower = c(-k, -k, 0, -k),\n                                                           upper = c(k, k, 1, k))))\n  estim_m1 <- lapply(1:m, function(i) NA)\n  hv <- which(!(sapply(1:m, function(i) is(try(switch(type,\n                                                      both = nls(data[, i] ~ regFce_noDIF(stand_total_score, group, a, b, c),\n                                                                 algorithm = \"port\",\n                                                                 start = start_m1[i, ],\n                                                                 lower = c(-k, -k, 0),\n                                                                 upper = c(k, k, 1)),\n                                                      nudif = nls(data[, i] ~ regFce_UDIF(stand_total_score, group, a, b, c, bDif),\n                                                                  algorithm = \"port\",\n                                                                  start = start_m1[i, ],\n                                                                  lower = c(-k, -k, 0, -k),\n                                                                  upper = c(k, k, 1, k)),\n                                                      udif = nls(data[, i] ~ regFce_noDIF(stand_total_score, group, a, b, c),\n                                                                 algorithm = \"port\", start = start_m1[i, ],\n                                                                 lower = c(-k, -k, 0),\n                                                                 upper = c(k, k, 1))),\n                                               silent = T),\n                                           \"try-error\"))))\n  estim_m1[hv] <- lapply(hv, function(i) switch(type, both = nls(data[, i] ~ regFce_noDIF(stand_total_score, group, a, b, c),\n                                                                 algorithm = \"port\",\n                                                                 start = start_m1[i, ],\n                                                                 lower = c(-k, -k, 0),\n                                                                 upper = c(k, k, 1)),\n                                                nudif = nls(data[, i] ~ regFce_UDIF(stand_total_score, group, a, b, c, bDif),\n                                                            algorithm = \"port\",\n                                                            start = start_m1[i, ],\n                                                            lower = c(-k, -k, 0, -k),\n                                                            upper = c(k, k, 1, k)),\n                                                udif = nls(data[, i] ~ regFce_noDIF(stand_total_score, group, a, b, c),\n                                                           algorithm = \"port\",\n                                                           start = start_m1[i, ],\n                                                           lower = c(-k, -k, 0),\n                                                           upper = c(k, k, 1))))\n\n  conv.fail <- conv.fail + sum(is.na(estim_m1) | is.na(estim_m0))\n  conv.fail.which <- which(is.na(estim_m1) | is.na(estim_m0))\n  if (conv.fail > 0) {\n    warning(\"Convergence failure\")\n  }\n\n  if (test == \"F\"){\n    pval <- Fval <- rep(NA, m)\n    df <- switch(type,\n                 both = c(2, n - 5),\n                 udif = c(1, n - 4),\n                 nudif = c(1, n - 5))\n    Fval[which(!((is.na(estim_m1)) | (is.na(estim_m0))))] <- sapply(which(!((is.na(estim_m1)) |  (is.na(estim_m0)))),\n                                                                    function(l) ((estim_m1[[l]]$m$deviance() - estim_m0[[l]]$m$deviance())/df[1])/(estim_m0[[l]]$m$deviance()/df[2]))\n    pval[which(!((is.na(estim_m1)) | (is.na(estim_m0))))] <- sapply(which(!((is.na(estim_m1)) | (is.na(estim_m0)))),\n                                                                    function(l) (1 - pf(Fval[l], df[1], df[2])))\n  } else {\n    pval <- LRval <- rep(NA, m)\n    df <- switch(type,\n                 both = 2,\n                 udif = 1,\n                 nudif = 1)\n    LRval[which(!((is.na(estim_m1)) | (is.na(estim_m0))))] <- sapply(which(!((is.na(estim_m1)) |  (is.na(estim_m0)))),\n                                                                    function(l) -2 * c(logLik(estim_m1[[l]]) - logLik(estim_m0[[l]])))\n    pval[which(!((is.na(estim_m1)) | (is.na(estim_m0))))] <- sapply(which(!((is.na(estim_m1)) | (is.na(estim_m0)))),\n                                                                    function(l) (1 - pchisq(LRval[l], df)))\n  }\n  pval_adj <- p.adjust(pval, method = p.adjust.method)\n  significant <- which(pval_adj < alpha)\n  if (length(significant) > 0) {\n    DIF <- significant\n  }\n  else {\n    DIF <- \"NONE\"\n  }\n\n  coef <- ifelse(pval_adj < alpha, lapply(estim_m0[which(!is.na(estim_m0))], coef),\n                                  lapply(estim_m1[which(!is.na(estim_m1))], coef))\n  vcov <- ifelse(pval_adj < alpha, lapply(estim_m0[which(!is.na(estim_m0))], vcov),\n                                  lapply(estim_m1[which(!is.na(estim_m1))], vcov))\n\n  mat <- t(sapply(coef, \"[\", i = 1:5))\n  mat[is.na(mat)] <- 0\n  coef <- switch(type, both = mat, nudif = mat[, c(1:3, 5, 4)], udif = mat[, c(1:3, 5, 4)])\n  colnames(coef) <- c(letters[1:3], \"aDif\", \"bDif\")\n  results <- list(DIF = DIF,\n                  test = test, Sval = switch(test, \"F\" = Fval, \"LR\" = LRval), Pval = pval_adj, df = df,\n                  coef = coef, vcov = vcov,\n                  group = group, data = data, type = type, alpha = alpha,\n                  conv.fail = conv.fail, conv.fail.which = conv.fail.which,\n                  p.adjust.method = p.adjust.method)\n  class(results) <- \"difNLR\"\n  results\n}\n\n\n#' @rdname difNLR\n#' @export\nprint.difNLR <- function (x, ...){\n  title <- switch(x$type,\n                  both = \"Detection of both types of Differential Item Functioning using Non-Linear Regression method\",\n                  udif = \"Detection of uniform Differential Item Functioning using Non-Linear Regression method\",\n                  nudif = \"Detection of non-uniform Differential Item Functioning using Non-Linear Regression method\")\n  cat(paste(strwrap(title, width = 60), collapse = \"\\n\"))\n  cat(switch(x$test,\n             \"F\" = \"\\n\\nNon-linear regression F-test statistics\\n\",\n             \"LR\" = \"\\n\\nNon-linear regression Likelihood Ratio chi-square statistics\\n\"))\n  if (x$p.adjust.method == \"none\") {\n    cat(\"p-values with none multiple comparison correction\\n\\n\")\n  }\n  else {\n    cat(paste(\"p-values adjusted using\", switch(x$p.adjust.method,\n                                                holm = \"Holm\", hochberg = \"Hochberg\", hommel = \"Hommel\",\n                                                bonferroni = \"Bonferroni\", BH = \"Benjamini-Hochberg\",\n                                                BY = \"Benjamini-Yekutieli\", fdr = \"FDR\"), \"method\\n\\n\"))\n  }\n  tab <- format(round(cbind(x$Sval, x$Pval), 4))\n  sign <- ifelse(is.na(x$Pval), \" \", ifelse(x$Pval < 0.001,\n                                            \"***\", ifelse(x$Pval < 0.01, \"**\", ifelse(x$Pval < 0.05,\n                                                                                      \"*\", ifelse(x$Pval < 0.1, \".\", \" \")))))\n  tab <- matrix(cbind(tab, sign), ncol = 3)\n  rownames(tab) <- paste(\"Item\", 1:length(x$Pval))\n  colnames(tab) <- switch(x$test,\n                          \"F\" = c(\"F-value\", \"P-value\", \"\"),\n                          \"LR\" = c(\"Chisq-value\", \"P-value\", \"\"))\n  print(tab, quote = F, digits = 4, zero.print = F)\n  cat(\"\\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\\n\")\n  n <- nrow(x$data)\n  df <- switch(x$type,\n               both = c(2, n - 5),\n               udif = c(1, n - 4),\n               nudif = c(1, n - 5))\n  df <- ifelse(x$test == \"F\", df, df[1])\n  critical <- ifelse(x$test == \"F\", qf(1 - x$alpha, df[1], df[2]), qchisq(1 - x$alpha, df))\n  cat(paste(\"\\nDetection thresholds: \", round(critical, 4), \" (significance level: \", x$alpha, \")\", sep = \"\"))\n  if (is.character(x$DIF)) {\n    switch(x$type, both = cat(\"\\nNone of items is detected as DIF\"),\n           udif = cat(\"\\nNone of items is detected as uniform DIF\"),\n           nudif = cat(\"\\nNone of items is detected as non-uniform DIF\"))\n  }\n  else {\n    switch(x$type, both = cat(\"\\nItems detected as DIF items:\\n\"),\n           udif = cat(\"\\nItems detected as uniform DIF items:\\n\"),\n           nudif = cat(\"\\nItems detected as non-uniform DIF items:\\n\"))\n    cat(\"\\n\", paste(\"Item \", x$DIF, \"\\n\", sep = \"\"))\n  }\n}\n\n#' @rdname difNLR\n#' @export\nplot.difNLR <- function(x, plot.type = \"cc\", item = \"all\",\n                        col = c(\"dodgerblue2\", \"goldenrod2\"),\n                        shape = 21, size = .8,\n                        linetype = c(2, 1), title,\n                        ...){\n\n  plotstat <- function(x, size = size, title = title){\n    if (x$conv.fail != 0){\n      if (length(x$conv.fail) == length(x$Sval)){\n        switch(x$test, \"F\" = stop(\"None of items does converge. F-statistic values not plotted\", call. = FALSE),\n                       \"LR\" = stop(\"None of items does converge. LR-statistic values not plotted\", call. = FALSE))\n      } else {\n        switch(x$test, \"F\" = warning(paste(\"Item \", x$conv.fail.which, \" does not converge. F-statistic value not plotted\",\n                                           sep = \"\", collapse = \"\\n\"), call. = FALSE),\n                       \"LR\" = warning(paste(\"Item \", x$conv.fail.which, \" does not converge. LR-statistic value not plotted\",\n                                           sep = \"\", collapse = \"\\n\"), call. = FALSE))\n      }\n    }\n\n    if(missing(title)){\n      title <- \"Non-Linear Regression DIF Detection \\n with None Multiple Comparison Correction\"\n    }\n    n <- nrow(x$data)\n    Sval_critical <- switch(x$test, \"F\" = qf(1 - x$alpha, x$df[1], x$df[2]), \"LR\" = qchisq(1 - x$alpha, x$df))\n    g <- as.factor(ifelse(x$Sval > Sval_critical, 1, 0))\n    items <- setdiff(1:length(x$Sval), x$conv.fail.which)\n    hv <- na.omit(as.data.frame(cbind(1:length(x$Sval), x$Sval, g)))\n    plot_stat <- ggplot(hv, aes_string(x = \"V1\", y = \"V2\",\n                                       label = as.character(\"V1\"),\n                                       col = as.factor(g))) +\n                  ### points\n                  geom_text() +\n                  scale_color_manual(values = c(\"black\", \"red\")) +\n                  ### critical value\n                  geom_hline(yintercept = Sval_critical, size = size) +\n                  ### theme\n                  ggtitle(title) +\n                  labs(x = \"Item\", y = switch(x$test, \"F\" = \"F-statistic\", \"LR\" = \"Chisq-statistic\")) +\n                  theme_bw() +\n                  theme(text = element_text(size = 11),\n                        plot.title = element_text(size = 11, face = \"bold\", vjust = 1.5),\n                        axis.line  = element_line(colour = \"black\"),\n                        panel.grid.major = element_blank(),\n                        panel.grid.minor = element_blank(),\n                        plot.background = element_rect(fill = \"transparent\", colour = NA),\n                        axis.text.x = element_blank(),\n                        axis.ticks.x = element_blank(),\n                        legend.position = \"none\")\n\n    print(plot_stat)\n  }\n\n  plotCC <- function(x, item = item,\n                     col = col, shape = shape, size = size,\n                     linetype = linetype, title = title){\n    m <- nrow(x$coef)\n    if (class(item) == \"character\"){\n      if (item != \"all\")\n        stop(\"'item' must be either numeric vector or character string 'all' \",\n             call. = FALSE)\n    } else {\n      if (class(item) != \"integer\" & class(item) != \"numeric\")\n        stop(\"'item' must be either numeric vector or character string 'all' \",\n             call. = FALSE)\n    }\n    if (class(item) == \"numeric\" & !all(item %in% 1:m))\n      stop(\"invalid number of 'item'\",\n           call. = FALSE)\n    if (class(item) == \"integer\" & !all(item %in% 1:m))\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n    if (length(col) == 1){\n      col <- rep(col, 2)\n    } else {\n      if (length(col) > 2){\n        col <- col[1:2]\n        warning(\"Length of 'col' is greater than 2. Only first two values are used\",\n                call. = FALSE)\n      }\n    }\n    if (class(item) == \"character\"){\n      items <- 1:m\n    } else {\n      items <- item\n    }\n    if (any(x$conv.fail.which %in% items)){\n      if (length(setdiff(items, x$conv.fail.which)) == 0){\n        stop(paste(\"Item \", intersect(x$conv.fail.which, items), \" does not converge. Characteristic curve not plotted\",\n                   sep = \"\", collapse = \"\\n\"),\n             call. = FALSE)\n      } else {\n        warning(paste(\"Item \", intersect(x$conv.fail.which, items), \" does not converge. Characteristic curve not plotted\",\n                      sep = \"\", collapse = \"\\n\"),\n                call. = FALSE)\n        items <- setdiff(items, x$conv.fail.which)\n      }\n    }\n    if (length(linetype) != 2){\n      if (length(linetype) == 1){\n        linetype <- rep(linetype, 2)\n      } else {\n        linetype <- linetype[1:2]\n        warning(\"Length of 'linetype' is greater than 2. Only first two values are used\",\n                call. = FALSE)\n      }\n    }\n    if (!missing(title)){\n      TITLE <- title\n    }\n\n    ### functions\n    regFce_nonUDIF <- function(STS, group, a, b, c, aDif, bDif){\n      return(c + (1 - c)/(1 + exp(-(a + aDif*group)*(STS - (b + bDif*group)))))\n    }\n\n    ### data\n    stand_total_score_R <- c(scale(apply(x$data[x$group == 0, ], 1, sum)))\n    stand_total_score_F <- c(scale(apply(x$data[x$group == 1, ], 1, sum)))\n    max_sts <- max(as.numeric(levels(as.factor(stand_total_score_R))),\n                   as.numeric(levels(as.factor(stand_total_score_F))))\n    min_sts <- min(as.numeric(levels(as.factor(stand_total_score_R))),\n                   as.numeric(levels(as.factor(stand_total_score_F))))\n    alpha <- 0.5\n    plot_CC <- list()\n\n    for (i in items){\n      hv_R <- data.frame(cbind(as.numeric(levels(as.factor(stand_total_score_R))),\n                               tapply(x$data[x$group == 0, i],\n                                      as.factor(stand_total_score_R), mean)))\n      hv_F <- data.frame(cbind(as.numeric(levels(as.factor(stand_total_score_F))),\n                               tapply(x$data[x$group == 1, i],\n                                      as.factor(stand_total_score_F), mean)))\n      hv   <- data.frame(rbind(cbind(hv_R, Group = \"Reference\"),\n                               cbind(hv_F, Group = \"Focal\")))\n      rownames(hv) <- 1:dim(hv)[1]\n      hv$size <- c(table(stand_total_score_R),\n                   table(stand_total_score_F))\n      if (missing(title)){\n        TITLE <- paste(\"Item\", i)\n      }\n      plot_CC[[i]] <- ggplot(hv, aes_string(\"X1\", \"X2\")) +\n                      ### points\n                      geom_point(aes_string(colour = \"Group\", fill = \"Group\",\n                                            size = \"size\"),\n                                 alpha = alpha, shape = shape) +\n                      ### lines\n                      stat_function(aes(colour = \"Reference\", linetype = \"Reference\"),\n                                    fun = regFce_nonUDIF,\n                                    args = list(group = 0,\n                                                a = x$coef[i, 1], b = x$coef[i, 2], c = x$coef[i, 3],\n                                                aDif = x$coef[i, 4], bDif = x$coef[i, 5]),\n                                    size = size,\n                                    geom = \"line\") +\n                      stat_function(aes(colour = \"Focal\", linetype = \"Focal\"),\n                                    fun = regFce_nonUDIF,\n                                    args = list(group = 1,\n                                                a = x$coef[i, 1], b = x$coef[i, 2], c = x$coef[i, 3],\n                                                aDif = x$coef[i, 4], bDif = x$coef[i, 5]),\n                                    size = size,\n                                    geom = \"line\") +\n                      ### style\n                      scale_size_continuous(name = \"Counts\")  +\n                      scale_colour_manual(breaks = hv$Group, values = col, name = \"Group\") +\n                      scale_fill_manual(breaks = hv$Group, values = col, name = \"Group\") +\n                      scale_linetype_manual(breaks = hv$Group, values = linetype, name = \"Group\") +\n                      ### theme\n                      ggtitle(TITLE) +\n                      labs(x = \"Standardized total score\", y = \"Probability of correct answer\") +\n                      scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +\n                      theme_bw() +\n                      theme(text = element_text(size = 11),\n                            plot.title = element_text(size = 11, face = \"bold\", vjust = 1.5),\n                            axis.line  = element_line(colour = \"black\"),\n                            panel.grid.major = element_blank(),\n                            panel.grid.minor = element_blank(),\n                            plot.background = element_rect(fill = \"transparent\", colour = NA)) +\n                      ### legend\n                      theme(legend.box.just = \"left\",\n                            legend.justification = c(1, 0),\n                            legend.position = c(0.97, 0.03),\n                            legend.margin = unit(0, \"lines\"),\n                            legend.box = \"vertical\",\n                            legend.key.size = unit(0.9, \"cm\"),\n                            legend.key.height = unit(0.8, \"line\"),\n                            legend.text.align = 0,\n                            legend.title.align = 0,\n                            legend.key = element_rect(colour = \"white\"))\n    }\n\n    plot_CC <- Filter(Negate(function(i) is.null(unlist(i))), plot_CC)\n    # names(plot_CC) <- paste(\"Item\", items)\n    class(plot_CC)\n\n    return(plot_CC)\n  }\n  ### checking input\n  if (!(plot.type %in% c(\"cc\", \"stat\"))){\n    stop(\"Possible values of 'plot.type' is 'cc' or 'stat' \",\n         call. = FALSE)\n  } else {\n    if (plot.type == \"cc\"){\n      plotCC(x, item = item,\n             col = col, shape = shape, size = size,\n             linetype = linetype, title = title)\n    } else {\n      plotstat(x, size = size, title = title)\n    }\n  }\n}\n\n#' @rdname difNLR\n#' @export\nfitted.difNLR <- function(object, item = \"all\", ...){\n\n  ### checking input\n  m <- nrow(object$coef)\n  if (class(item) == \"character\"){\n    if (item != \"all\")\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n  } else {\n    if (class(item) != \"integer\" & class(item) != \"numeric\")\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n  }\n  if (class(item) == \"numeric\" & !all(item %in% 1:m))\n    stop(\"invalid number of 'item'\",\n         call. = FALSE)\n  if (class(item) == \"integer\" & !all(item %in% 1:m))\n    stop(\"'item' must be either numeric vector or character string 'all' \",\n         call. = FALSE)\n  if (class(item) == \"character\"){\n    items <- 1:m\n  } else {\n    items <- item\n  }\n  if (any(object$conv.fail.which %in% items)){\n    if (length(setdiff(items, object$conv.fail.which)) == 0){\n      stop(paste(\"Item \", intersect(object$conv.fail.which, items), \" does not converge. No values displayed\",\n                 sep = \"\", collapse = \"\\n\"),\n           call. = FALSE)\n    } else {\n      warning(paste(\"Item \", intersect(object$conv.fail.which, items), \" does not converge. No values displayed\",\n                    sep = \"\", collapse = \"\\n\"),\n              call. = FALSE)\n      items <- setdiff(items, object$conv.fail.which)\n    }\n  }\n\n\n  ### functions\n  NLR <- function(STS, group, a, b, c, aDif, bDif){\n    return(c + (1 - c)/(1 + exp(-(a + aDif*group)*(STS - (b + bDif*group)))))\n  }\n\n  ### data\n  STS <- c(scale(apply(object$data, 1, sum)))\n\n  ### fitted values\n  FV <- lapply(items, function(i) NLR(STS, object$group, object$coef[i, 1], object$coef[i, 2],\n                                      object$coef[i, 3], object$coef[i, 4], object$coef[i, 5]))\n  FV <- lapply(FV, setNames, NULL)\n  names(FV) <- paste(\"Item\", items)\n  return(FV)\n\n}\n\n#' @rdname difNLR\n#' @export\npredict.difNLR <- function(object, item = \"all\",\n                           score, group, ...){\n\n  ### checking input\n  m <- nrow(object$coef)\n  if (class(item) == \"character\"){\n    if (item != \"all\")\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n  } else {\n    if (class(item) != \"integer\" & class(item) != \"numeric\")\n      stop(\"'item' must be either numeric vector or character string 'all' \",\n           call. = FALSE)\n  }\n  if (class(item) == \"numeric\" & !all(item %in% 1:m))\n    stop(\"invalid number of 'item'\",\n         call. = FALSE)\n  if (class(item) == \"integer\" & !all(item %in% 1:m))\n    stop(\"'item' must be either numeric vector or character string 'all' \",\n         call. = FALSE)\n  if (missing(score)){\n    score <- c(scale(apply(object$data, 1, sum)))\n  }\n  if (missing(group)){\n    group <- object$group\n  }\n  if(length(score) != length(group)){\n    stop(\"'score' and 'group' must be the same length\",\n         call. = FALSE)\n  }\n  if (class(item) == \"character\"){\n    items <- 1:m\n  } else {\n    items <- item\n  }\n  if (any(object$conv.fail.which %in% items)){\n    if (length(setdiff(items, object$conv.fail.which)) == 0){\n      stop(paste(\"Item \", intersect(object$conv.fail.which, items), \" does not converge. No values displayed\",\n                 sep = \"\", collapse = \"\\n\"),\n           call. = FALSE)\n    } else {\n      warning(paste(\"Item \", intersect(object$conv.fail.which, items), \" does not converge. No values displayed\",\n                    sep = \"\", collapse = \"\\n\"),\n              call. = FALSE)\n      items <- setdiff(items, object$conv.fail.which)\n    }\n  }\n  ### functions\n  NLR <- function(STS, group, a, b, c, aDif, bDif){\n    return(c + (1 - c)/(1 + exp(-(a + aDif*group)*(STS - (b + bDif*group)))))\n  }\n\n  ### data\n  STS <- score\n\n\n  ### predicted values\n  PV <- lapply(items, function(i) NLR(STS, group, object$coef[i, 1], object$coef[i, 2],\n                                      object$coef[i, 3], object$coef[i, 4], object$coef[i, 5]))\n  PV <- lapply(PV, setNames, NULL)\n  names(PV) <- paste(\"Item\", items)\n  return(predict = PV)\n}\n\n\n",
    "created" : 1476951468154.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3517719596",
    "id" : "25C97CAF",
    "lastKnownWriteTime" : 1478629361,
    "last_content_update" : 1478629361070,
    "path" : "C:/Users/Adisa/Dropbox/Work/CRAN packages/difNLR v 0.2.0/difNLR/R/difNLR.R",
    "project_path" : "R/difNLR.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}