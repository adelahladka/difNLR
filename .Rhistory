alpha = alpha))
STATS <- PROV$Sval
ADJ.PVAL <- PROV$adjusted.pval
se.m1 <- lapply(lapply(PROV$cov.m1, diag), sqrt)
se.m0 <- lapply(lapply(PROV$cov.m0, diag), sqrt)
significant <- which(ADJ.PVAL < alpha)
if (length(significant) > 0) {
DDFitems <- significant
mlrPAR <- PROV$par.m1
mlrSE <- se.m1
for (idif in 1:length(DDFitems)) {
mlrPAR[[DDFitems[idif]]] <- PROV$par.m0[[DDFitems[idif]]]
mlrSE[[DDFitems[idif]]] <- se.m0[[DDFitems[idif]]]
}
} else {
DDFitems <- "No DDF item detected"
mlrPAR <- PROV$par.m1
mlrSE <- se.m1
}
RES <- list(Sval = STATS,
mlrPAR = mlrPAR,
mlrSE = mlrSE,
parM0 = PROV$par.m0,
# seM0 = PROV$se.m0, covM0 = PROV$cov.m0,
parM1 = PROV$par.m1,
# seM1 = PROV$se.m1, covM1 = PROV$cov.m1,
alpha = alpha, DDFitems = DDFitems,
type = type, p.adjust.method = p.adjust.method,
pval = PROV$pval, adj.pval = PROV$adjusted.pval, df = PROV$df,
adjusted.p = NULL,
group = GROUP, Data = DATA, key = key,
llM0 = PROV$ll.m0, llM1 = PROV$ll.m1,
AICM0 = PROV$AIC.m0, AICM1 = PROV$AIC.m1,
BICM0 = PROV$BIC.m0, BICM1 = PROV$BIC.m1)
class(RES) <- "ddfMLR"
return(RES)
}
resToReturn <- internalMLR()
return(resToReturn)
}
#' @rdname ddfMLR
#' @export
print.ddfMLR <- function (x, ...){
title <- switch(x$type,
both = "Detection of both types of Differential Distractor Functioning using Multinomial Log-linear Regression model",
udif = "Detection of uniform Differential Distractor Functioning using Multinomial Log-linear Regression model",
nudif = "Detection of non-uniform Differential Distractor Functioning using Multinomial Log-linear Regression model")
cat(paste(strwrap(title, width = 60), collapse = "\n"))
cat("\n\nLikelihood-ratio chi-square statistics\n")
if (x$p.adjust.method == "none") {
cat("No p-value adjustment for multiple comparisons\n\n")
}
else {
cat(paste("Multiple comparisons made with",
switch(x$p.adjust.method,
holm = "Holm", hochberg = "Hochberg", hommel = "Hommel",
bonferroni = "Bonferroni", BH = "Benjamini-Hochberg",
BY = "Benjamini-Yekutieli", fdr = "FDR"), "adjustment of p-values\n\n"))
}
sign <- ifelse(is.na(x$adj.pval), " ",
ifelse(x$adj.pval < 0.001, "***",
ifelse(x$adj.pval < 0.01, "**",
ifelse(x$adj.pval < 0.05, "*",
ifelse(x$adj.pval < 0.1, ".", " ")))))
if (x$p.adjust.method == "none"){
tab <- format(round(cbind(x$Sval, x$pval), 4))
tab <- matrix(cbind(tab, sign), ncol = 3)
colnames(tab) <- c("Chisq-value", "P-value", "")
} else {
tab <- format(round(cbind(x$Sval, x$pval, x$adj.pval), 4))
tab <- matrix(cbind(tab, sign), ncol = 4)
colnames(tab) <- c("Chisq-value", "P-value", "Adj. P-value", "")
}
rownames(tab) <- colnames(x$Data)
print(tab, quote = F, digits = 4, zero.print = F)
cat("\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n")
# critical <- ifelse(x$test == "F", qf(1 - x$alpha, x$df[1], x$df[2]), qchisq(1 - x$alpha, x$df))
# cat(paste("\nDetection thresholds: ", round(critical, 4), " (significance level: ", x$alpha, ")", sep = ""))
if (is.character(x$DDFitems)) {
switch(x$type, both = cat("\nNone of items is detected as DDF"),
udif = cat("\nNone of items is detected as uniform DDF"),
nudif = cat("\nNone of items is detected as non-uniform DDF"))
}
else {
switch(x$type, both = cat("\n\nItems detected as DDF items:"),
udif = cat("\n\nItems detected as uniform DDF items:"),
nudif = cat("\n\nItems detected as non-uniform DDF items:"))
cat("\n", paste(colnames(x$Data)[x$DDFitems], "\n", sep = ""))
}
}
#' @rdname ddfMLR
#' @export
plot.ddfMLR <- function(x, item = "all", title, ...){
m <- length(x$mlrPAR)
if (class(item) == "character"){
if (item != "all")
stop("'item' must be either numeric vector or character string 'all' ",
call. = FALSE)
} else {
if (class(item) != "integer" & class(item) != "numeric")
stop("'item' must be either numeric vector or character string 'all' ",
call. = FALSE)
}
if (class(item) == "numeric" & !all(item %in% 1:m))
stop("invalid number of 'item'",
call. = FALSE)
if (class(item) == "integer" & !all(item %in% 1:m))
stop("'item' must be either numeric vector or character string 'all' ",
call. = FALSE)
if (class(item) == "character"){
items <- 1:m
} else {
items <- item
}
score <- c(scale(unlist(CTT::score(x$Data, x$key))))
sq <- seq(min(score), max(score), by = 0.1)
sqR <- as.matrix(data.frame(1, sq, 0, 0))
sqF <- as.matrix(data.frame(1, sq, 1, sq))
plot_CC <- list()
for (i in items){
if (!missing(title)){
TITLE <- title
} else {
TITLE <- colnames(x$Data)[i]
}
if(ncol(x$mlrPAR[[i]]) == 2)
x$mlrPAR[[i]] <- as.matrix(data.frame(x$mlrPAR[[i]], 0, 0))
prR <- prF <- c()
for (j in 1:nrow(x$mlrPAR[[i]])){
prR <- rbind(prR, exp(x$mlrPAR[[i]][j, ] %*% t(sqR)))
prF <- rbind(prF, exp(x$mlrPAR[[i]][j, ] %*% t(sqF)))
}
prR <- as.data.frame(t(prR)); prF <- as.data.frame(t(prF))
colnames(prR) <- colnames(prF) <- rownames(x$mlrPAR[[i]])
prR$sum <- apply(prR, 1, sum) + 1; prF$sum <- apply(prF, 1, sum) + 1
for (j in 1:nrow(x$mlrPAR[[i]])){
prR <- data.frame(prR, prR[, j]/prR[, "sum"])
prF <- data.frame(prF, prF[, j]/prF[, "sum"])
}
hvR <- data.frame(1 - apply(prR[, (nrow(x$mlrPAR[[i]])+2):ncol(prR)], 1, sum),
prR[, (nrow(x$mlrPAR[[i]])+2):ncol(prR)], "R")
hvF <- data.frame(1 - apply(prF[, (nrow(x$mlrPAR[[i]])+2):ncol(prF)], 1, sum),
prF[, (nrow(x$mlrPAR[[i]])+2):ncol(prF)], "F")
hvR <- data.frame(hvR, score = sq)
hvF <- data.frame(hvF, score = sq)
colnames(hvR) <- colnames(hvF) <- c(paste(x$key[i]), rownames(x$mlrPAR[[i]]), "group", "score")
hv <- rbind(hvR, hvF)
df <- reshape2::melt(hv, id = c("score", "group"))
df$group <- as.factor(df$group)
df2 <- rbind(data.frame(prop.table(table(x$Data[x$group == 1, i], score[x$group == 1]), 2),
table(x$Data[x$group == 1, i], score[x$group == 1]),
group = "1"),
data.frame(prop.table(table(x$Data[x$group == 0, i], score[x$group == 0]), 2),
table(x$Data[x$group == 0, i], score[x$group == 0]),
group = "0"))
df2$score <- as.numeric(levels(df2$Var2))[df2$Var2]
df2$answ <- relevel(df2$Var1, ref = paste(x$key[i]))
df2$group <- as.factor(df2$group)
df$variable <- relevel(df$variable, ref = paste(x$key[i]))
plot_CC[[i]] <-  ggplot() +
geom_line(data = df,
aes_string(x = "score" , y = "value",
colour = "variable", linetype = "group")) +
geom_point(data = df2,
aes_string(x = "score", y = "Freq",
colour = "answ", fill = "answ",
size = "Freq.1"),
alpha = 0.5, shape = 21) +
ylim(0, 1) +
ggtitle(TITLE) +
labs(x = "Standardized total score",
y = "Probability of answer") +
scale_linetype_discrete(name = "Group", labels = c("Reference", "Focal")) +
scale_size_continuous(name = "Counts")  +
scale_colour_discrete(name = "Answer", breaks = df2$answ) +
scale_fill_discrete(guide = F) +
theme_bw() +
theme(axis.line  = element_line(colour = "black"),
text = element_text(size = 11),
plot.title = element_text(size = 11, face = "bold", vjust = 1.5),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
legend.position = c(0, 1),
legend.justification = c(0, 1),
legend.background = element_blank(),
legend.box = "horizontal",
legend.key = element_rect(colour = "white"),
legend.key.width = unit(0.8, "cm"),
legend.key.height = unit(0.5, "cm"),
legend.spacing.x = unit(-0.05, "cm"))
}
plot_CC <- Filter(Negate(function(i) is.null(unlist(i))), plot_CC)
return(plot_CC)
}
#' @rdname ddfMLR
#' @export
logLik.ddfMLR <- function(object, ...){
m <- length(object$mlrPAR)
LL <- ifelse(1:m %in% object$DIFitems, object$llM0, object$llM1)
return(LL)
}
#' @rdname ddfMLR
#' @export
AIC.ddfMLR <- function(object, ...){
m <- length(object$mlrPAR)
AIC <- ifelse(1:m %in% object$DDFitems, object$AICM0, object$AICM1)
return(AIC)
}
#' @rdname ddfMLR
#' @export
BIC.ddfMLR <- function(object, ...){
m <- length(object$mlrPAR)
BIC <- ifelse(1:m %in% object$DDFitems, object$BICM0, object$BICM1)
return(BIC)
}
data(GMATtest, GMATkey)
Data  <- GMATtest[, 1:20]
group <- GMATtest[, "group"]
key <- GMATkey
# Testing both DDF effects
x <- ddfMLR(Data, group, focal.name = 1, key)
# Testing both DDF effects with Benjamini-Hochberg adjustment method
ddfMLR(Data, group, focal.name = 1, key, p.adjust.method = "BH")
ddfMLR(Data, group, focal.name = 1, key, type = "udif")
# Testing non-uniform DDF effects
ddfMLR(Data, group, focal.name = 1, key, type = "nudif")
plot(x, item = 1)
plot(x, item = x$DDFitems)
plot(x, item = "all")
AIC(x)
object$mlrPAR
x
object <- x
m <- length(object$mlrPAR)
m
LL <- ifelse(1:m %in% object$DIFitems, object$llM0, object$llM1)
LL
m <- length(object$mlrPAR)
AIC <- ifelse(1:m %in% object$DDFitems, object$AICM0, object$AICM1)
object$DDFitems
1:m %in% object$DDFitems
object$AICM0
object$AICM1
object
#' DDF likelihood ratio statistics based on Multinomial Log-linear Regression model.
#'
#' @aliases MLR
#'
#' @description Calculates DDF likelihood ratio statistics based on multinomial log-linear model.
#'
#' @param Data character: the unscored data matrix.
#' @param group numeric or character: the binary vector of group membership
#' @param key character: the answer key.
#' @param type character: type of DDF to be tested (either "both" (default), "udif", or "nudif").
#' See \strong{Details}.
#' @param p.adjust.method character: method for multiple comparison correction.
#' See \strong{Details}.
#' @param alpha numeric: significance level (default is 0.05).
#'
#' @usage MLR(Data, group, key, type = "both", p.adjust.method = "none", alpha = 0.05)
#' @details
#' Calculates DDF likelihood ratio statistics based on multinomial log-linear model.
#'
#' The \code{Data} is a matrix whose rows represents examinee unscored answers and
#' columns correspond to the items. The \code{group} must be a vector of the same
#' length as \code{nrow(data)}. The \code{key} must be a vector of correct answers
#' corresponding to columns of \code{Data}.
#'
#' The \code{type} corresponds to type of DDF to be tested. Possible values are \code{"both"}
#' to detect any DDF (uniform and/or non-uniform), \code{"udif"} to detect only uniform DDF or
#' \code{"nudif"} to detect only non-uniform DDF.
#'
#' The \code{p.adjust.method} is a character for \code{p.adjust} function from the
#' \code{stats} package. Possible values are \code{"holm"}, \code{"hochberg"},
#' \code{"hommel"}, \code{"bonferroni"}, \code{"BH"}, \code{"BY"}, \code{"fdr"}, \code{"none"}.
#'
#'
#' @return A list with the following arguments:
#' \describe{
#'   \item{\code{Sval}}{the values of likelihood ratio test statistics.}
#'   \item{\code{pval}}{the p-values by likelihood ratio test.}
#'   \item{\code{adj.pval}}{the adjusted p-values by likelihood ratio test using \code{p.adjust.method}.}
#'   \item{\code{df}}{the degress of freedom of likelihood ratio test.}
#'   \item{\code{par.m0}}{the estimates of null model.}
#'   \item{\code{par.m1}}{the estimates of alternative model.}
#'   \item{\code{cov.m0}}{the estimates of covariance structure of null model.}
#'   \item{\code{cov.m1}}{the estimates of covariance structure of alternative model.}
#'   \item{\code{ll.m0}}{log-likelihood of m0 model.}
#'   \item{\code{ll.m1}}{log-likelihood of m1 model.}
#'   \item{\code{AIC.m0}}{AIC of m0 model.}
#'   \item{\code{AIC.m1}}{AIC of m1 model.}
#'   \item{\code{BIC.m0}}{BIC of m0 model.}
#'   \item{\code{BIC.m1}}{BIC of m1 model.}
#'   }
#'
#' @author
#' Adela Drabinova \cr
#' Institute of Computer Science, The Czech Academy of Sciences \cr
#' Faculty of Mathematics and Physics, Charles University \cr
#' adela.drabinova@gmail.com \cr
#'
#' Patricia Martinkova \cr
#' Institute of Computer Science, The Czech Academy of Sciences \cr
#' martinkova@cs.cas.cz \cr
#'
#'
#' @seealso \code{\link[stats]{p.adjust}}
#'
#' @examples
#' \dontrun{
#' # loading data based on GMAT
#' data(GMATtest, GMATkey)
#'
#' Data  <- GMATtest[, 1:20]
#' group <- GMATtest[, "group"]
#' key <- GMATkey
#'
#' # Testing both DDF effects
#' MLR(Data, group, key, type = "both")
#'
#' # Testing uniform DDF effects
#' MLR(Data, group, key, type = "udif")
#'
#' # Testing non-uniform DDF effects
#' MLR(Data, group, key, type = "nudif")
#' }
#' @keywords DDF
#' @export
#' @importFrom stats coef vcov p.adjust.methods anova
#' @importFrom nnet multinom
#' @importFrom CTT score
MLR <- function(Data, group, key, type = "both", p.adjust.method = "none", alpha = 0.05){
x <- c(scale(unlist(CTT::score(Data, key))))
m <- ncol(Data)
n <- nrow(Data)
m0 <- lapply(1:m, function(i) switch(type,
"both" = nnet::multinom(relevel(as.factor(Data[, i]),
ref = paste(key[i])) ~ x * group,
trace = F),
"nudif" = nnet::multinom(relevel(as.factor(Data[, i]),
ref = paste(key[i])) ~ x * group,
trace = F),
"udif" = nnet::multinom(relevel(as.factor(Data[, i]),
ref = paste(key[i])) ~ x + group,
trace = F)))
m1 <- lapply(1:m, function(i) switch(type,
"both" = nnet::multinom(relevel(as.factor(Data[, i]),
ref = paste(key[i])) ~ x,
trace = F),
"nudif" = nnet::multinom(relevel(as.factor(Data[, i]),
ref = paste(key[i])) ~ x + group,
trace = F),
"udif" = nnet::multinom(relevel(as.factor(Data[, i]),
ref = paste(key[i])) ~ x,
trace = F)))
MLRtest <- lapply(1:m, function(i) anova(m0[[i]], m1[[i]]))
MLRstat <- sapply(1:m, function(i) c(MLRtest[[i]]$`LR stat.`[2], MLRtest[[i]]$`Pr(Chi)`[2]))
df <- lapply(1:m, function(i) MLRtest[[i]]$`Resid. df`)
adjusted.pval <- p.adjust(MLRstat[2, ], method = p.adjust.method)
par.m1 <- lapply(m1, coef)
par.m0 <- lapply(m0, coef)
cov.m1 <- lapply(m1, vcov)
cov.m0 <- lapply(m0, vcov)
# se.m1 <- sqrt(t(sapply(cov.m1, diag)))
# se.m0 <- sqrt(t(sapply(cov.m0, diag)))
ll.m0 <- sapply(m0, logLik)
ll.m1 <- sapply(m0, logLik)
AIC.m0 <- sapply(m0, AIC)
AIC.m1 <- sapply(m1, AIC)
BIC.m0 <- sapply(m0, BIC)
BIC.m1 <- sapply(m1, BIC)
results <- list(Sval = MLRstat[1, ],
pval = MLRstat[2, ], adjusted.pval = adjusted.pval,
df = df,
par.m0 = par.m0, cov.m0 = cov.m0,
par.m1 = par.m1, cov.m1 = cov.m1,
ll.m0 = ll.m0, ll.m1 = ll.m1,
AIC.m0 = AIC.m0, AIC.m1 = AIC.m1,
BIC.m0 = BIC.m0, BIC.m1 = BIC.m1)
return(results)
}
data(GMATtest, GMATkey)
Data  <- GMATtest[, 1:20]
group <- GMATtest[, "group"]
key <- GMATkey
# Testing both DDF effects
x <- ddfMLR(Data, group, focal.name = 1, key)
AIC(x)
BIC(x)
logLik(x)
devtools::document
devtools::document()
library(difNLR)
devtools::document()
data(GMAT)
Data  <- GMAT[, 1:20]
group <- GMAT[, "group"]
x <- difNLR(Data, group, focal.name = 1, model = "3PLcg")
AIC(x)
BIC(x)
logLik(x)
devtools::document()
library(difNLR)
devtools::build()
devtools::document()
devtools::build()
devtools::document()
library(difNLR)
data(GMATtest, GMATkey)
Data  <- GMATtest[, 1:20]
group <- GMATtest[, "group"]
key <- GMATkey
x <-
ddfMLR(Data, group, focal.name = 1, key, type = "nudif")
library(difNLR)
x <-
ddfMLR(Data, group, focal.name = 1, key, type = "nudif")
plot(x, item = 1)
plot(x)
m <- length(x$mlrPAR)
m
x$mlrPAR
score <- c(scale(unlist(CTT::score(x$Data, x$key))))
sq <- seq(min(score), max(score), by = 0.1)
sqR <- as.matrix(data.frame(1, sq, 0, 0))
sqF <- as.matrix(data.frame(1, sq, 1, sq))
plot_CC <- list()
items
items <- 1
i <- 1
TITLE <- colnames(x$Data)[i]
TITLE
ncol(x$mlrPAR[[i]]) == 2
x$mlrPAR[[i]]
prR <- prF <- c()
prR <- rbind(prR, exp(x$mlrPAR[[i]][j, ] %*% t(sqR)))
x$mlrPAR[[i]][j, ]
nrow(x$mlrPAR[[i]])
x$mlrPAR[[i]]
t(sqR)
if(ncol(x$mlrPAR[[i]]) == 3)
x$mlrPAR[[i]] <- as.matrix(data.frame(x$mlrPAR[[i]], 0))
for (j in 1:nrow(x$mlrPAR[[i]])){
prR <- rbind(prR, exp(x$mlrPAR[[i]][j, ] %*% t(sqR)))
prF <- rbind(prF, exp(x$mlrPAR[[i]][j, ] %*% t(sqF)))
}
prR
prF
prR <- as.data.frame(t(prR)); prF <- as.data.frame(t(prF))
colnames(prR) <- colnames(prF) <- rownames(x$mlrPAR[[i]])
prR$sum <- apply(prR, 1, sum) + 1; prF$sum <- apply(prF, 1, sum) + 1
for (j in 1:nrow(x$mlrPAR[[i]])){
prR <- data.frame(prR, prR[, j]/prR[, "sum"])
prF <- data.frame(prF, prF[, j]/prF[, "sum"])
}
hvR <- data.frame(1 - apply(prR[, (nrow(x$mlrPAR[[i]])+2):ncol(prR)], 1, sum),
prR[, (nrow(x$mlrPAR[[i]])+2):ncol(prR)], "R")
hvF <- data.frame(1 - apply(prF[, (nrow(x$mlrPAR[[i]])+2):ncol(prF)], 1, sum),
prF[, (nrow(x$mlrPAR[[i]])+2):ncol(prF)], "F")
hvR <- data.frame(hvR, score = sq)
hvF <- data.frame(hvF, score = sq)
colnames(hvR) <- colnames(hvF) <- c(paste(x$key[i]), rownames(x$mlrPAR[[i]]), "group", "score")
hv <- rbind(hvR, hvF)
df <- reshape2::melt(hv, id = c("score", "group"))
df$group <- as.factor(df$group)
df2 <- rbind(data.frame(prop.table(table(x$Data[x$group == 1, i], score[x$group == 1]), 2),
table(x$Data[x$group == 1, i], score[x$group == 1]),
group = "1"),
data.frame(prop.table(table(x$Data[x$group == 0, i], score[x$group == 0]), 2),
table(x$Data[x$group == 0, i], score[x$group == 0]),
group = "0"))
df2$score <- as.numeric(levels(df2$Var2))[df2$Var2]
df2$answ <- relevel(df2$Var1, ref = paste(x$key[i]))
df2$group <- as.factor(df2$group)
df$variable <- relevel(df$variable, ref = paste(x$key[i]))
plot_CC[[i]] <-  ggplot() +
geom_line(data = df,
aes_string(x = "score" , y = "value",
colour = "variable", linetype = "group")) +
geom_point(data = df2,
aes_string(x = "score", y = "Freq",
colour = "answ", fill = "answ",
size = "Freq.1"),
alpha = 0.5, shape = 21) +
ylim(0, 1) +
ggtitle(TITLE) +
labs(x = "Standardized total score",
y = "Probability of answer") +
scale_linetype_discrete(name = "Group", labels = c("Reference", "Focal")) +
scale_size_continuous(name = "Counts")  +
scale_colour_discrete(name = "Answer", breaks = df2$answ) +
scale_fill_discrete(guide = F) +
theme_bw() +
theme(axis.line  = element_line(colour = "black"),
text = element_text(size = 11),
plot.title = element_text(size = 11, face = "bold", vjust = 1.5),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
legend.position = c(0, 1),
legend.justification = c(0, 1),
legend.background = element_blank(),
legend.box = "horizontal",
legend.key = element_rect(colour = "white"),
legend.key.width = unit(0.8, "cm"),
legend.key.height = unit(0.5, "cm"),
legend.spacing.x = unit(-0.05, "cm"))
plot_CC[[i]]
devtools::document()
library(difNLR)
library(difNLR)
